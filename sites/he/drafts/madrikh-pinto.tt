=title Pinto -- פינטו 
=timestamp 2013-03-15T07:30:01
=indexes cpan, pinto
=status show
=original pinto-tutorial
=author thalhammer
=translator bruck
=index 1
=archive 1
=feed 1
=comments 1
=social 1

=abstract start

<i>
רשומה זו היא רשומת אורח מאת <href="http://twitter.com/thaljef">Jeffrey Ryan Thalhammer ג'פרי רייאן תאלהמר</a>
המפתח של פינטו (Pinto) ושל Perl::Critic. ג'ף מנהל עסק קטן לייעוץ בסן פרנסיסקו והוא פעיל בקהילת הפרל במשך שנים רבות.
ג'ף מנסה  <a href="https://www.crowdtilt.com/campaigns/specify-module-version-ranges-in-pint">לגייס כעת מימון</a> לפיתוח היכולות שיאפשרו לציין טווחים של מספרי גירסאות בפינטו.
</i>

אחת המעלות הבולטות של פרל היא כל המודולים בקוד פתוח שניתן למצוא על CPAN.
אך בכלל לא קל להתעדכן בכל החידושים והעדכונים. בכל שבוע מופצים מאות עידכונים חדשים
ואי אפשר לדעת באיזו גירסה של מודול יופיע פתאום באג חדש שיפיל את היישום שלך.


=abstract end

אחד הפתרונות האפשריים לבעיה זו היא ליצור מאגר CPAN משלך המכיל רק את גרסאות המודולים הרצויות לך.
תוכל להשתמש בכלי CPAN לבניית היישום שלך מהמודולים שנמצאים במאגר שלך, שהותאם לצרכיך,
בלי לחשוף את עצמך לכל הפעלתנות של המאגר הציבורי של CPAN.

במשך השנים בניתי מספר מאגרי CPAN מותאמים אישית באמצעות כלים כמו 
<a href="https://metacpan.org/module/CPAN::Mini">CPAN::Mini</a>
ו-<a href="https://metacpan.org/module/CPAN::Site">CPAN::Site</a>.
אך הם תמיד נראו מגושמים ולא ממש הייתי מאושר איתם. לפני מספר שנים, לקוח שכר אותו 
לפתח עוד מערכת CPAN מותאמת ללקוח. אך הפעם הייתה לי הזדמנות להתחיל מאפס. 
פינטו (Pinto) הוא התוצאה של אותו פרוייקט.


<a href="https://metacpan.org/module/Pinto">פינטו</a> הוא כלי עתיר יכולות
להקמת מאגר CPAN ולניהולו.
יש לו מספר תכונות רבות עוצמה שמסייעות לנהל
 בביטחה את כל מודולי הפרל הנחוצים ליישום שלך.
מדריך זה יראה כיצג ליצור מאגר CPAN מותאם אישים באמצעות פינטו וידגים חלק מהיכולות של פינטו.


<h2>התקנת פינטו</h2>

פינטו זמין ב-CPAN וניתן להתקינו כמו כל מודול אחר באמצעות הכלי cpan או <hl>cpanm</hl>.
פינטו דומה יותר ליישום מאשר לספרייה. הוא כללי שמאפשר לך לנהל את קוד היישום שלך, 
אך הוא לא חלק מהיישום. 
לכן אני ממליץ להתקין את פינטו כיישום בפני עצמו  באמצעות הפקודות הבאות:

<code>
curl -L http://getpinto.stratopan.com | bash
source ~/opt/local/pinto/etc/bashrc
</code>

פקודות אלו יתקינו את פינו ב <hl>~/opt/local/pinto</hl> ויוסיפו את התיקיות הדרושות למסלולים
ב- <hl>PATH</hl> וב- <hl>MANPATH</hl>.
ההתקנה כוללת את כל מה שפינטו צריך, כך שהתקנת פינטו לא משנה את 
שאר סביבת הפיתוח שלך, וכמו כן שינויים בסביבת הפיתוח אינם משפיעים על פינטו.


<h2>ללמוד להשתמש בפינטו</h2>

כמו כל כלי חדש, הדבר הראשון שצריך לדעת הוא איך לקבל עזרה:


<code>
pinto commands            # Show a list of available commands
pinto help <COMMAND>      # Show a summary of options and arguments for <COMMAND>
pinto manual <COMMAND>    # Show the complete manual for <COMMAND>
</code>

פינטו מגיע גם עם תיעוד נוסף, כולל מדריך שימוש ומדריך לעיון מהיר.
ניתן לדשת אל מסמכים אלו באמצעות הפקודות:

<code>
man Pinto::Manual::Introduction  # Explains basic Pinto concepts
man Pinto::Manual::Installing    # Suggestions for installing Pinto
man Pinto::Manual::Tutorial      # A narrative guide to Pinto
man Pinto::Manual::QuickStart    # A summary of common commands
</code>

<h2>יצירת מאגר</h2>

השלב הראשון בשימוש בפינטו הוא יצירת מאגר באמצעות הפקודה <hl>init</hl>:

<code>
pinto -r ~/repo init
</code>

פקודוה זו תיצור מאגר חדש בתיקייה <hl>~/repo</hl>. אם התיקייה אינה קיימת, היא תיווצר עבורך.
אם היא כבר קיימת אז היא חייבת להיות ריקה.

האופציה -r  (או -root) מציינת את מיקום המאגר. יש לציין זאת בכל פקודת פינטו.
אבל אם נמאם לכם לחזור ולהקליד זאת שוב ושוב,
אבל אם נמאס לך לחזור ולהקליד זאת שוב ושוב, אז תוכל להגדיר את מיקום המאגר במשתנה הסביבה
 <hl>PINTO_REPOSITORY_ROOT</hl> ואז אין צורך להשתמש עוד ב -r .


<h2>בדיקת המאגר</h2>

עכשיו שיש לנו מאגר,נבדוק ומראה מה יש בו.
כדי לראות את תוכן המאגר, השתמש בפקודה "list":

<code>
pinto -r ~/repo list
</code>

בשלב זה הרשימה תהיה ריקה כיוון שאין עוד כלום במאגר. אך הפקודה "list" תופיע די הרבה בהמשך 
ההדרכה.


<h2>הוספת מודולים מ-CPAN </h2>

נניח שאתה עובד כעת על יישום שנקרא My-App המכיל מודל בדם My::App, והוא מסתמך על 
המודול URI.  אתה יכול להכניס את המודול URI אל המאגר שלך באמצעות הפקודה <hl>pull</hl>:

<code>
pinto -r ~/repo pull URI
</code>

תתבקש להקליד הודעה עבור הלוג שתתאר את הסיבה לשינוי. 
בראש תבנית ההודעה יש הודעה פשוטה, , שיוצרה אוטומטית, ואתה יכול לערו אותה.
תחתית תבנית ההודעה מראה את רשימת המודולים המדוייקת שנוספו.
שמור את הקובץ וסגור את עורך הטקסט לאחר שסיימת.

כעת מודול ה-URI אמור להיות במאגר הפינטו שלך. חזור שוב על הפקודה <hl>list</hl>
כדי לראות את תוכן המאגר:

<code>
pinto -r ~/repo list
</code>

הפעם הרשימה תיראה דומה לרשימה זו:

<code>
rf  URI                            1.60  GAAS/URI-1.60.tar.gz
rf  URI::Escape                    3.31  GAAS/URI-1.60.tar.gz
rf  URI::Heuristic                 4.20  GAAS/URI-1.60.tar.gz
...
</code>

ניתן לראות שהמודול URI נוסף למאגר, וכמו כן גם כל המודולים הדרושים כדרישות קדם למודול URI
וכל דרישות הקדם שלהם, וכו'.

<h2>הוספת מודולים פרטיים</h2>

כעת נניח שסיימת את העבודה של My-App ואתה מוכל להפיץ את הגירסה הראשונה.
ארוז את המודול כמודול להפצה My-App-1.0.tar.gz 
 באמצעות הכלי המועדף עליך (למשל: ExtUtils::MakםeMaker, Module::Build, Module::Install וכו').
הוסף את קובץ. ההפצה שלך למאגר הפינטו שלך באמצעות הפקודה <hl>add</hl>:

<code>
$> pinto -r ~/repo add path/to/My-App-1.0.tar.gz
</code>


גם במקרה זה תתבקש להכניס הודעה שמתארת את השינוי. כשתציג את תוכן המעגר כעת, הוא יכלול גם
את המודול My::App ויציג אותך כיוצר ההפצה:

<code>
rl  My::App                         1.0  JEFF/My-App-1.0.tar.gz
rf  URI                            1.60  GAAS/URI-1.60.tar.gz
rf  URI::Escape                    3.31  GAAS/URI-1.60.tar.gz
rf  URI::Heuristic                 4.20  GAAS/URI-1.60.tar.gz
...
</code>


<h2>התקנת המודולים</h2>

לאחר שכל המודולים שלך נמצאים במאגר הפינטו שלך, השלב הוא בא או להתקין אותם איפשהו.
בתוך הופסה, מאגר פינטו מנוהל בדיוק כמו מאגר CPAN,
לכן הוא תואם לגמרי ל-cpanm ולכל כלי אחר להתקנת מודולי פרל.
כל מה שנדרש הוא להפנות את כלי ההתקנה למאגר הפינטו שלך:

<code>
cpanm --mirror file://$HOME/repo --mirror-only My::App
</code>

פקודה זו תבנה ותתקין את My::App *אך ורק* בשימוש במודולים שנמצאים 
במאגר הפינטו שלך. כך תקבל בדיוק את אותן גרסאות של המודולים עם כל התקנה,
אפילו אם המודול שודרג המאגר CPAN הפומבי או הוסר ממנו.

עם cpanm האופציה --mirror-only היא אופציה חשובה, כיוון שהיא מונעת
מ-cpanm לפנות אל מעגר ה-CPAN הפומבי אם המודול אינו נמצא במאגר שלך. 
אם זה קורה, אז כנראה יש שגיאה בהגדרת דרישות הקדם בקובץ ה-META
של אחד המודולים במאגר שלך. ניתן לפתור את הבעיה על ידי שימוש בפקודה 
<hl>pull</hl> כדי להוסיף את המודולים החסרים.


<h2>שידרוג מודולים</h2>

נניח שעברו מספר שבועות מאז שהפצת לראשונה את My-App ומודול URI עודכן על CPAN 
1.62. בגירסה החדשה יש מספר תיקוני באגים חיוניים שאתה רוצה לקבל.
שוב, נוכל להכניס את המודול אל המאגר באמצעות הפקודה  <hl>pull</hl>.
אך כיוון שבמאגר שלך כבר יש גירסה של מודול URI, עליך לציין שברצונך להכניס גירסה 
 <b>חדשה יותר</b> על ידי מספר הגירסה המינימלי שרצוי לך:


<code>
pinto -r ~/repo pull URI~1.62
</code>

אם תסתכל שוב על רשימת תוכן המאגר תראה הפעם את הגרסה החדשה יותר של המודול URI (וייתכן שגם תראה מודולים נוספים):

<code>
rl  My::App                         1.0  JEFF/My-App-1.0.tar.gz
rf  URI                            1.62  GAAS/URI-1.62.tar.gz
rf  URI::Escape                    3.38  GAAS/URI-1.62.tar.gz
rf  URI::Heuristic                 4.20  GAAS/URI-1.62.tar.gz
...
</code>

אם הגירסה החדשה מסתמכת על  מודולים נוספים או על מודולים אחרים ששודרגו,
גם הם יהיו במאגר שלך. כשתתקין את My::App, תקבל גם את גירסה 1.62 של URI.


<h2>שימוש במחסניות (Stacks)</h2>


בינתיים התייחסנו אל המגר כאל משב יחיד. כך כששידרגנו את URI בחלק הקודם, 
הפעולה השפיעה על כל משתמש ועל כל יישום שהשתמשו במאגר. 
השפעה כל כך גורפת אינה רצויה. עדיף לעשות את שינויים בסביבה מבודדת ולבדוק אותם 
לפני שמחייבים את כולם לשדרג. בשביל זה נועדו המחסניות (Stacks).

לכל מאגר דמוי CPAN יש אינדקס שמקשר את הגירסה העדכנית ביותר של כל מודול לארכיון שמכיל אותה.
לרוב יש אינדקס אחד לכל מאגר. במאגר פינטו יכול להיות יותר מאינדקס אחד.
כל אינדקס נקרה <b>"stack"</b>. זה מאפשר יצירת מחסניות שונות עם תלויות בדרישות קדם שונות בתוך מאגר.
ניתן לנהל מחסנית "development" לפיתוח ובנוסף מחסנית "production" לגרסאות להפצה, 
או מחסנית "perl-5.8" ומחסנית "perl-5.16". כל הוספת מודול או עידכונו משפיעים רק על מחסנית אחת.

לפני שתמשיך צריך להכיר את מחסנית ברירת המחדל (default stack).
ברוב הפעולות אין צורך לציין את שם המחסנית. אם לא מציינים במפורש שם מחסנית
אז הפקודה מופעלת על המחסנית שמסומנת כמחסנית ברירת המחדל.


בכל מאגר, בכל רגע נתון, יש תמיד לכל היותר מחסנית ברירת מחדל אחת. 
כשיצרנו את המאגר נוצרה גם מחסנית בשם "master" והיא סומנה כמחסנית ברירת המחדל.
ניתן לשנות את מחסנית ברירת המחדל, או את שם המחסנית, אבל לא ניכנס לזה כאן.
פשוט יש לזכור ש-"master" הוא שמה של המחסנית שנוצרה כשיצרנו את המאגר.

<h3>יצירת מחסנית (Stack)</h3>


נניח שהמאגר שלך מכיל את גירסה 1.60 של URI אבל ב-CPAN הגירסה המעודכנית היא גירסה 1.62, כמו בדוגמה הקודמת.
אתה רוצה לנסות את שדרוג, אבל הפעם אתה הולך לנסות אותו במחסנית נפרדת.

עד כה, כל מה שהוספת או הכנסת למאגר נכנס למחסנית "master". אז קודם כל ניצור העתק של המחסנית
בעזרת הפקודה  <hl>copy</hl>:

<code>
pinto -r ~/repo copy master uri_upgrade
</code>

פקודה זו יוצרת מחסנית חדשה בשם "uri_upgrade". אם תרצה לראות את תוכן המחסנית החדשה, השתמש בפקודה
<hl>list</hl> אם האופציה "--stack":


<code>
pinto -r ~/repo list --stack uri_upgrade
</code>

הרשימה צריכה להיות זהה לרשימה במחסנית "master":

<code>
rl  My::App                         1.0  JEFF/My-App-1.0.tar.gz
rf  URI                            1.60  GAAS/URI-1.60.tar.gz
...
</code>

<h3>שידרוג מחסנית (Stack)</h3>

עכשיו כשיש לך מחסנית נפרדת, אתה יכול לנסות לשדרג את URI. כמו קודם, תשתמש בפקודה
<hl>pull</hl> . רק הפעם תאמר לפינו להכניס את המודולים אל המחסנית "uri_upgrade" :

<code>
pinto -r ~/repo pull --stack uri_upgrade URI~1.62
</code>

עכשיו ניתן להשוות את המחסניות "master" ו- "uri_upgrade" באמצעות הפקודה "diff":

<code>
pinto -r ~/repo diff master uri_upgrade

+rf URI                                              1.62 GAAS/URI-1.62.tar.gz
+rf URI::Escape                                      3.31 GAAS/URI-1.62.tar.gz
+rf URI::Heuristic                                   4.20 GAAS/URI-1.62.tar.gz
...
-rf URI                                              1.60 GAAS/URI-1.60.tar.gz
-rf URI::Escape                                      3.31 GAAS/URI-1.60.tar.gz
-rf URI::Heuristic                                   4.20 GAAS/URI-1.60.tar.gz
</code>

הקלט דומה לקלט של הפקודה diff(1).
רשומות שמתחילות ב "+" הן רשומות שנוספו ורשומות שמתחילות ב "-" הן רשומות שהוסרו. 
ניתן לראות שמודולים מההפצה של URI-1.60 הוחלפו במודולים מההפצה URI-1.62.


<h3>התקנה ממחסנית (Stack)</h3>

לאחר שהמודולים החדשים הותקנו במחסנית "uri_upgrade" תוכל לנסות לבנות ולהתקין את היישום שלך
על ידי כך שתפנה את cpanm אל המחסנית.
מחסנית היא בסך הכל תת-תיקייה בתוך המאגר, כך שכל מה שיש לעשות הוא להוסיף אותה אל ה-URL:

<code>
cpanm --mirror file://$HOME/repo/stacks/uri_upgrade --mirror-only My::App
</code>

אם כל הבדיקות עבור בהצלחה, תוכל לשדרג בביטחה את מודול URI
לגירסה 1.62 גם במחסנית "master" בעזרת הפקודה <hl>pull</hl>.
כיוון שמחסנית "master" היא מחסנית ברירת המחדל, אין צורך לציין את שם המחסנית:

<code>
pinto -r ~/repo pull URI~1.62
</code>

<h2>Working With Pins</h2>

Stacks are a great way to test the effect of changing your application
dependencies.  But what if the tests didn't pass?  If the problem lies
within My-App and you can quickly correct it, you might just modify
your code, release version 2.0 of My-App, and then proceed to upgrade
URI on the "master" stack.

But if the issue is a bug in URI or it will take a long time to fix
My-App, then you have a problem.  You don't want someone else to
upgrade URI, nor do you want it to be upgraded inadvertently to
satisfy some other prerequisite that My-App may have.  Until you know
the problem is fixed, you need to prevent URI from being upgraded.
This is what pins are for.

<h3>Pinning A Module</h3>

When you pin a module, that version of the module is forced to stay in
a stack.  Any attempt to upgrade it (either directly or via another
prerequisite) will fail.  To pin a module, use the <hl>pin</hl> command:

<code>
pinto -r ~/repo pin URI
</code>

If you look at the listing for the "master" stack again, you'll see
something like this:

<code>
...
rl  My::App                         1.0  JEFF/My-App-1.0.tar.gz
rf! URI                            1.60  GAAS/URI-1.60.tar.gz
rf! URI::Escape                    3.31  GAAS/URI-1.60.tar.gz
...
</code>

The "!" near the beginning of a record indicates the module has been
pinned.  If anyone attempts to upgrade URI or a add distribution that
requires a newer version of URI, then Pinto will give a warning and
refuse to accept the new distributions.  Notice that every module in
the URI-1.60 distribution has been pinned, so it is impossible to
partially upgrade a distribution (this situation could happen when a
module moves into a different distribution).

<h3>Unpinning A Module</h3>

After a while, suppose you fix the problem in My-App or a new version
of URI is released that fixes the bug.  When that happens, you can
unpin URI from the stack using the <hl>unpin</hl> command:

<code>
pinto -r ~/repo unpin URI
</code>

At this point you're free to upgrade URI to the latest version
whenever you're ready.  Just as with pinning, when you unpin a module
it unpins every other module it the distribution as well.

<h2>Using Pins And Stacks Together</h2>

Pins and stacks are often used together to help manage change during
the development cycle.  For example, you could create a stack called
"prod" that contains your known-good dependencies.  At the same time,
you could also create a stack called "dev" that contains experimental
dependencies for your next release.  Initially, the "dev" stack is
just a copy of the "prod" stack.

As development proceeds, you may upgrade or add several modules on the
"dev" stack.  If an upgraded module breaks your application, then
you'll place a pin in that module on the "prod" stack to signal that
it shouldn't be upgraded.

<h3>Pins and Patches</h3>

Sometimes you may find that a new version of a CPAN distribution has a
bug but the author is unable or unwilling to fix it (at least not
before your next release is due).  In that situation, you may decide
to make a local patch of the CPAN distribution.

So suppose that you forked the code for URI and made a local version
of the distribution called URI-1.60_PATCHED.tar.gz.  You can add it to
your repository using the <hl>add</hl> command:

<code>
pinto -r ~/repo add path/to/URI-1.60_PATCHED.tar.gz
</code>

In this situation, it is wise to pin the module as well, since you do
not want it to be upgraded until you are sure that the new version
from CPAN includes your patch or the author has fixed the bug by other
means.

<code>
pinto -r ~/repo pin URI
</code>

When the author of URI releases version 1.62, you'll want to test it
before deciding to unpin from your locally patched version.  Just as
before, this can be done by cloning the stack with the <hl>copy</hl> command.
Let's call it the "trial" stack this time:

<code>
pinto -r ~/repo copy master trial
</code>

But before you can upgrade URI on the "trial" stack, you'll have to
unpin it there:

<code>
pinto -r ~/repo unpin --stack trial URI
</code>

Now you can proceed to upgrade URI on the stack and try building
My::App like this:

<code>
pinto -r ~/repo pull --stack trial URI~1.62
cpanm --mirror file://$HOME/repo/stacks/trial --mirror-only My::App
</code>

If all goes well, remove the pin from the "master" stack and pull the
newer version of URI back into it.

<code>
pinto -r ~/repo unpin URI
pinto -r ~/repo pull URI~1.62
</code>

<h2>Reviewing Past Changes</h2>

As you've probably noticed by now, each command that changes the state
of a stack requires a log message to describe it.  You can review
those messages using the <hl>log</hl> command:

<code>
pinto -r ~/repo log
</code>

That should display something like this:

<code>
revision 4a62d7ce-245c-45d4-89f8-987080a90112
Date: Mar 15, 2013 1:58:05 PM
User: jeff

     Pin GAAS/URI-1.59.tar.gz

     Pinning URI because it is not causes our foo.t script to fail

revision 4a62d7ce-245c-45d4-89f8-987080a90112
Date: Mar 15, 2013 1:58:05 PM
User: jeff

     Pull GAAS/URI-1.59.tar.gz

     URI is required for HTTP support in our application

...
</code>

The header for each message shows who made the change and when it happened.
It also has a unique identifier similar to Git's SHA-1 digests.  You can
use these identifiers to see the diffs between different revisions or to
reset the stack back to a prior revision [NB: this feature is not actually
implemented yet].

<h2>Conclusion</h2>

In this tutorial, you've seen the basic commands for creating a Pinto
repository and populating it with modules.  You've also seen how to
use stacks and pins to manage your dependencies in the face of some
common development obstacles.

Each command has several options that were not discussed in this
tutorial, and there are some commands that were not mentioned here at
all.  So I encourage you to explore the manual pages for each command
and learn more.

