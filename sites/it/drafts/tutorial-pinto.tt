=title Pinto -- Un Archivio CPAN Personalizzato In Confezione Regalo
=timestamp 2013-03-15T07:30:01
=indexes cpan, pinto
=status show
=original pinto-tutorial
=author szabgab
=translator giatorta
=index 1
=archive 1
=feed 1
=comments 1
=social 1

=abstract start

<i>
Questo contributo è di <a href="http://twitter.com/thaljef">Jeffrey Ryan Thalhammer</a>, autore di Pinto
e di Perl::Critic. Jeff dirige una piccola impresa di consulenza a San Francisco ed
 è attivo nella comunità Perl da molti anni.
Till May 7 Jeff is running a <a href="https://www.crowdtilt.com/campaigns/specify-module-version-ranges-in-pint">fund-raiser</a>
to finance the development of the feature that will allow you to <b>specify module version ranges in Pinto</b>.
</i>

Uno dei punti di forza di Perl sono i suoi moduli open source
disponibili su CPAN. Purtroppo stare al passo con tutti gli aggiornamenti che li riguardano è
difficile. Ogni settimana ci sono centinaia di nuovi rilasci e non
potete sapere se una nuova versione di un modulo introdurrà un bug che
blocca la vostra applicazione.

=abstract end

Una strategia per risolvere questo problema è quella di creare un vostro archivio CPAN
personalizzato che contenga soltanto le versioni dei moduli che
volete. In questo modo potete usare i tool di CPAN per creare la vostra
applicazione con i moduli del vostro archivio personalizzato, evitando di
esporvi agli imprevisti che si possono verificare usando l'archivio CPAN pubblico.

Nel corso degli anni ho creato svariati archivi CPAN personalizzati usando
tool come <a href="https://metacpan.org/module/CPAN::Mini">CPAN::Mini</a>
e <a href="https://metacpan.org/module/CPAN::Site">CPAN::Site</a>, ma
mi sono sempre sembrati macchinosi
e non mi hanno mai lasciato completamente soddisfatto.  Un paio di anni fa un
cliente mi ha assunto per creargli un ennessimo CPAN personalizzato. Questa volta, però, ho
avuto l'opportunità di ricominciare da zero. Pinto è il risultato di quel
lavoro.

<a href="https://metacpan.org/module/Pinto">Pinto</a> è un tool affidabile
per creare e gestire un archivio CPAN personalizzato.
Ha molte funzionalità che vi aiutano efficacemente a gestire
in modo sicuro tutti i moduli Perl da cui dipende la vostra applicazione. Questo
tutorial vi illustrerà come creare un CPAN personalizzato con Pinto e
come usare alcune delle sue funzionalità.

<h2>Installare Pinto</h2>

Pinto è disponibile su CPAN e può essere installato come un qualunque altro modulo
usando le utility cpan o <hl>cpanm</hl>. Ma Pinto, più che una libreria,
è un'applicazione. È un tool che usate per gestire il codice della
vostra applicazione ma non è parte effettiva della vostra applicazione.
Perciò vi suggerisco di installare Pinto come una applicazione stand-alone con
questi due comandi:

<code>
curl -L http://getpinto.stratopan.com | bash
source ~/opt/local/pinto/etc/bashrc
</code>

In questo modo Pinto verrà installato in <hl>~/opt/local/pinto</hl> e le opportune directory
saranno aggiunte ai vostri <hl>PATH</hl> e <hl>MANPATH</hl>. L'applicazione è auto-contenuta,
quindi installare Pinto non ha effetti sul resto del vostro ambiente di
sviluppo e, viceversa, eventuali modifiche al vostro ambiente di sviluppo non hanno effetti su
Pinto.

<h2>Esploriamo Pinto</h2>

Come per ogni nuovo tool, la prima cosa che dovete imparare è come chiedere aiuto:

<code>
pinto commands            # Visualizza una lista di comandi disponibili
pinto help <COMMAND>      # Visualizza un riepilogo delle opzioni e argomenti di <COMMAND>
pinto manual <COMMAND>    # Visualizza il manuale completo di <COMMAND>
</code>

Pinto include anche altra documentazione, tra cui un tutorial e
una guida di riferimento rapido. Potete accedere a tali documenti con i seguenti
comandi:

<code>
man Pinto::Manual::Introduction  # Spiega i concetti base di Pinto
man Pinto::Manual::Installing    # Suggerimenti sull'installazione di Pinto
man Pinto::Manual::Tutorial      # Una guida su Pinto in stile narrativo
man Pinto::Manual::QuickStart    # Un riepilogo sui comandi più comuni
</code>

<h2>Creazione Di Un Archivio</h2>

Il primo passo nell'uso di Pinto è la creazione di un archivio con il comando
<hl>init</hl>:

<code>
pinto -r ~/repo init
</code>

Viene creato un nuovo archivio nella directory <hl>~/repo</hl>. Se la directory
non esiste viene creata automaticamente. Se invece esiste
deve essere vuota.

L'opzione -r (o --root) specifica l'ubicazione dell'archivio. È
richiesta da tutti i comandi di pinto. Se vi annoiate a riscriverla ogni volta,
potete settare la variabile d'ambiente <hl>PINTO_REPOSITORY_ROOT</hl> per farla puntare al
vostro archivio e poter omettere l'opzione -r.


<h2>Ispezione Dell'Archivio</h2>

Ora che avete creato un archivio, diamo un'occhiata a che cosa contiene. Per visualizzare il
contenuto di un archivio usate il comando "list":

<code>
pinto -r ~/repo list
</code>

Al momento la lista è vuota perché l'archivio non ha ancora
contenuti. Ma torneremo a usare spesso il comando "list"
in questo tutorial.

<h2>Aggiunta Di Moduli CPAN</h2>

Immaginate di lavorare ad una applicazione My-App che contiene
un modulo My::App e dipende dal modulo URI.  Potete
importare il modulo URI nel vostro archivio usando il comando <hl>pull</hl>:

<code>
pinto -r ~/repo pull URI
</code>

Vi viene chiesto di immettere un messaggio di log che descriva il perché di questo
cambiamento dell'archivio. La prima linea del template del messaggio include un
semplice messaggio generato automaticamente che potete editare. In fondo al template
del messaggio c'è invece l'elenco esatto dei moduli che sono stati aggiunti. Quando siete pronti
salvate il file e chiudete l'editor.

Ora il modulo URI dovrebbe essere nel vostro archivio. Proviamo a vedere
che cosa è successo. Usate di nuovo il comando <hl>list</hl>
per visualizzare il contenuto dell'archivio:

<code>
pinto -r ~/repo list
</code>

Questa volta l'elenco sarà qualcosa tipo:

<code>
rf  URI                            1.60  GAAS/URI-1.60.tar.gz
rf  URI::Escape                    3.31  GAAS/URI-1.60.tar.gz
rf  URI::Heuristic                 4.20  GAAS/URI-1.60.tar.gz
...
</code>

Come vedete, il modulo URI è stato aggiunto all'archivio insieme
a tutti i prerequisiti di URI, ai loro prerequisiti
e così via.

<h2>Aggiunta Di Moduli Privati</h2>

Ora immaginate di aver finito di lavorare su My-App e di essere pronti a
rilasciarne la prima versione.  Sfruttando il vostro strumento preferito di build (e.g
ExtUtils::MakeMaker, Module::Build, Module::Install etc.) generate
un package con la release My-App-1.0.tar.gz. A questo punto potete aggiungere la distribuzione
nell'archivio Pinto con il comando <hl>add</hl>:

<code>
$> pinto -r ~/repo add path/to/My-App-1.0.tar.gz
</code>

Vi verrà nuovamente chiesto di immettere un messaggio che descriva il cambiamento dell'archivio.
Quando elencate i contenuti dell'archivio, essi includeranno ora il modulo My::App
e vi menzioneranno come autori della distribuzione:

<code>
rl  My::App                         1.0  JEFF/My-App-1.0.tar.gz
rf  URI                            1.60  GAAS/URI-1.60.tar.gz
rf  URI::Escape                    3.31  GAAS/URI-1.60.tar.gz
rf  URI::Heuristic                 4.20  GAAS/URI-1.60.tar.gz
...
</code>


<h2>Installazione Di Moduli</h2>

Ora che i vostri moduli sono stati importati nell'archivio Pinto, il passo
successivo consiste nel farne il build e installarli da qualche parte. Dietro le quinte,
un archivio Pinto è organizzato esattamente come un archivio CPAN ed è quindi
completamente compatibile con cpanm e con gli altri tool per l'installazione di moduli Perl. Dovete
soltanto far puntare il tool di installazione al vostro archivio Pinto:

<code>
cpanm --mirror file://$HOME/repo --mirror-only My::App
</code>

Questo comando fa il build e l'installazione di My::App usando *solo* i moduli del vostro
archivio Pinto. Di conseguenza, ogni volta verranno usate esattamente le stesse versioni di tali
moduli, indipendentemente dal fatto che il modulo sia stato rimosso o aggiornato sull'archivio
CPAN pubblico.

L'opzione --mirror-only di cpanm è importante perché impedisce a
cpanm di ricorrere al CPAN pubblico quando non trova un modulo
nel vostro archivio. Quando ciò succede, normalmente è causato da qualche
distribuzione nell'archivio che non dichiara correttamente tutte le proprie
dipendenze nel proprio file META. Potete risolvere il problema semplicemente
usando il comando <hl>pull</hl> per recuperare i moduli mancanti.


<h2>Aggiornamento Di Moduli</h2>

Immaginate che sia passata qualche settimana dal vostro primo rilascio di My-App
e che ora su CPAN sia disponibile la versione 1.62 di URI. Dato che essa
include la soluzione di alcuni bug critici vorreste iniziare a usarla. Potete importarla
nell'archivio usando nuovamente il comando <hl>pull</hl>. Però, dato che il vostro
archivio contiene già una versione di URI, dovete indicare che
ne volete una <b>più recente</b> specificandone la versione minima:

<code>
pinto -r ~/repo pull URI~1.62
</code>

Se visualizzare il contenuto dell'archivio, questa volta vedrete la nuova 
versione di URI (ed eventualmente anche di altri moduli):

<code>
rl  My::App                         1.0  JEFF/My-App-1.0.tar.gz
rf  URI                            1.62  GAAS/URI-1.62.tar.gz
rf  URI::Escape                    3.38  GAAS/URI-1.62.tar.gz
rf  URI::Heuristic                 4.20  GAAS/URI-1.62.tar.gz
...
</code>

Se la nuova versione di URI richiede delle dipendenze nuove o
aggiornate, saranno anch'esse nell'archivio. E quando
installate di nuovo My::App verrà usata la versione 1.62 di URI.

<h2>Working With Stacks</h2>

Thus far, we've treated the repository as a singular resource.  So
when we upgraded URI in the last section, it affected every person and
every application that might have been using the repository.  But this
kind of broad impact is undesirable.  You would prefer to make changes
in isolation and test them before forcing everyone else to upgrade.
This is what stacks are designed for.

All CPAN-like repositories have an index which maps the latest version
of each module to the archive that contains it.  Usually, there is
only one index per repository.  But in a Pinto repository, there can
be many indexes.  Each of these indexes is called a <b>"stack"</b>.  This
allows you to create different stacks of dependencies within a single
repository.  So you could have a "development" stack and a
"production" stack, or a "perl-5.8" stack and a "perl-5.16" stack.
Whenever you add or upgrade a module, it only affects one stack.

But before going further, you need to know about the default stack.
For most operations, the name of the stack is an optional parameter.
So if you do not specify a stack explicitly, then the command is
applied to whichever stack is marked as the default.

In any repository, there is never more than one default stack.  When
we created this repository, a stack called "master" was also created and
marked as the default.  You can change the default stack or change the
name of a stack, but we won't go into that here.  Just remember that
"master" is the name of the stack that was created when the repository
was first initialized.

<h3>Creating A Stack</h3>

Suppose your repository contains version 1.60 of URI but version 1.62
has been released to the CPAN, just like before.  You want to try
upgrading, but this time you're going to do it on a separate stack.

Thus far, everything you've added or pulled into the repository has
gone into the "master" stack.  So we're just going to make a clone
of that stack using the <hl>copy</hl> command:

<code>
pinto -r ~/repo copy master uri_upgrade
</code>

This creates a new stack called "uri_upgrade".  If you want to see the
contents of that stack, just use the <hl>list</hl> command with the "--stack"
option:

<code>
pinto -r ~/repo list --stack uri_upgrade
</code>

The listing should be identical to the "master" stack:

<code>
rl  My::App                         1.0  JEFF/My-App-1.0.tar.gz
rf  URI                            1.60  GAAS/URI-1.60.tar.gz
...
</code>

<h3>Upgrading A Stack</h3>

Now that you've got a separate stack, you can try upgrading URI.  Just
as before, you'll use the <hl>pull</hl> command.  But this time, you'll tell
Pinto to pull the modules into the "uri_upgrade" stack:

<code>
pinto -r ~/repo pull --stack uri_upgrade URI~1.62
</code>

We can compare the "master" and "uri_upgrade" stacks using the "diff"
command:

<code>
pinto -r ~/repo diff master uri_upgrade

+rf URI                                              1.62 GAAS/URI-1.62.tar.gz
+rf URI::Escape                                      3.31 GAAS/URI-1.62.tar.gz
+rf URI::Heuristic                                   4.20 GAAS/URI-1.62.tar.gz
...
-rf URI                                              1.60 GAAS/URI-1.60.tar.gz
-rf URI::Escape                                      3.31 GAAS/URI-1.60.tar.gz
-rf URI::Heuristic                                   4.20 GAAS/URI-1.60.tar.gz
</code>

The output is similar to the diff(1) command. Records starting with a
"+" were added and those starting with a "-" were removed.  You can
see that modules from the URI-1.60 distribution have been replaced
with modules from the URI-1.62 distribution.

<h3>Installing From A Stack</h3>

Once you have new modules on the "uri_upgrade" stack, you can try
building your application by pointing cpanm at the stack.  Each stack
is just a subdirectory inside the repository, so all you have to do
is add it to the URL:

<code>
cpanm --mirror file://$HOME/repo/stacks/uri_upgrade --mirror-only My::App
</code>

If all the tests pass, then you can confidently upgrade URI to version
1.62 in the "master" stack as well by using the <hl>pull</hl> command.  Since
"master" is the default stack, you can omit the "--stack" paramter:

<code>
pinto -r ~/repo pull URI~1.62
</code>

<h2>Working With Pins</h2>

Stacks are a great way to test the effect of changing your application
dependencies.  But what if the tests didn't pass?  If the problem lies
within My-App and you can quickly correct it, you might just modify
your code, release version 2.0 of My-App, and then proceed to upgrade
URI on the "master" stack.

But if the issue is a bug in URI or it will take a long time to fix
My-App, then you have a problem.  You don't want someone else to
upgrade URI, nor do you want it to be upgraded inadvertently to
satisfy some other prerequisite that My-App may have.  Until you know
the problem is fixed, you need to prevent URI from being upgraded.
This is what pins are for.

<h3>Pinning A Module</h3>

When you pin a module, that version of the module is forced to stay in
a stack.  Any attempt to upgrade it (either directly or via another
prerequisite) will fail.  To pin a module, use the <hl>pin</hl> command:

<code>
pinto -r ~/repo pin URI
</code>

If you look at the listing for the "master" stack again, you'll see
something like this:

<code>
...
rl  My::App                         1.0  JEFF/My-App-1.0.tar.gz
rf! URI                            1.60  GAAS/URI-1.60.tar.gz
rf! URI::Escape                    3.31  GAAS/URI-1.60.tar.gz
...
</code>

The "!" near the beginning of a record indicates the module has been
pinned.  If anyone attempts to upgrade URI or a add distribution that
requires a newer version of URI, then Pinto will give a warning and
refuse to accept the new distributions.  Notice that every module in
the URI-1.60 distribution has been pinned, so it is impossible to
partially upgrade a distribution (this situation could happen when a
module moves into a different distribution).

<h3>Unpinning A Module</h3>

After a while, suppose you fix the problem in My-App or a new version
of URI is released that fixes the bug.  When that happens, you can
unpin URI from the stack using the <hl>unpin</hl> command:

<code>
pinto -r ~/repo unpin URI
</code>

At this point you're free to upgrade URI to the latest version
whenever you're ready.  Just as with pinning, when you unpin a module
it unpins every other module it the distribution as well.

<h2>Using Pins And Stacks Together</h2>

Pins and stacks are often used together to help manage change during
the development cycle.  For example, you could create a stack called
"prod" that contains your known-good dependencies.  At the same time,
you could also create a stack called "dev" that contains experimental
dependencies for your next release.  Initially, the "dev" stack is
just a copy of the "prod" stack.

As development proceeds, you may upgrade or add several modules on the
"dev" stack.  If an upgraded module breaks your application, then
you'll place a pin in that module on the "prod" stack to signal that
it shouldn't be upgraded.

<h3>Pins and Patches</h3>

Sometimes you may find that a new version of a CPAN distribution has a
bug but the author is unable or unwilling to fix it (at least not
before your next release is due).  In that situation, you may decide
to make a local patch of the CPAN distribution.

So suppose that you forked the code for URI and made a local version
of the distribution called URI-1.60_PATCHED.tar.gz.  You can add it to
your repository using the <hl>add</hl> command:

<code>
pinto -r ~/repo add path/to/URI-1.60_PATCHED.tar.gz
</code>

In this situation, it is wise to pin the module as well, since you do
not want it to be upgraded until you are sure that the new version
from CPAN includes your patch or the author has fixed the bug by other
means.

<code>
pinto -r ~/repo pin URI
</code>

When the author of URI releases version 1.62, you'll want to test it
before deciding to unpin from your locally patched version.  Just as
before, this can be done by cloning the stack with the <hl>copy</hl> command.
Let's call it the "trial" stack this time:

<code>
pinto -r ~/repo copy master trial
</code>

But before you can upgrade URI on the "trial" stack, you'll have to
unpin it there:

<code>
pinto -r ~/repo unpin --stack trial URI
</code>

Now you can proceed to upgrade URI on the stack and try building
My::App like this:

<code>
pinto -r ~/repo pull --stack trial URI~1.62
cpanm --mirror file://$HOME/repo/stacks/trial --mirror-only My::App
</code>

If all goes well, remove the pin from the "master" stack and pull the
newer version of URI back into it.

<code>
pinto -r ~/repo unpin URI
pinto -r ~/repo pull URI~1.62
</code>

<h2>Reviewing Past Changes</h2>

As you've probably noticed by now, each command that changes the state
of a stack requires a log message to describe it.  You can review
those messages using the <hl>log</hl> command:

<code>
pinto -r ~/repo log
</code>

That should display something like this:

<code>
revision 4a62d7ce-245c-45d4-89f8-987080a90112
Date: Mar 15, 2013 1:58:05 PM
User: jeff

     Pin GAAS/URI-1.59.tar.gz

     Pinning URI because it is not causes our foo.t script to fail

revision 4a62d7ce-245c-45d4-89f8-987080a90112
Date: Mar 15, 2013 1:58:05 PM
User: jeff

     Pull GAAS/URI-1.59.tar.gz

     URI is required for HTTP support in our application

...
</code>

The header for each message shows who made the change and when it happened.
It also has a unique identifier similar to Git's SHA-1 digests.  You can
use these identifiers to see the diffs between different revisions or to
reset the stack back to a prior revision [NB: this feature is not actually
implemented yet].

<h2>Conclusion</h2>

In this tutorial, you've seen the basic commands for creating a Pinto
repository and populating it with modules.  You've also seen how to
use stacks and pins to manage your dependencies in the face of some
common development obstacles.

Each command has several options that were not discussed in this
tutorial, and there are some commands that were not mentioned here at
all.  So I encourage you to explore the manual pages for each command
and learn more.

