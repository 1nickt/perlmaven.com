=title Crearea fişierelor cu Perl
=timestamp 2012-12-20T16:45:56
=indexes open, close, write, die, open or die, >, encoding, UTF-8
=status show
=books beginner_book
=author szabgab
=translator stefansbv
=index 1
=archive 1
=feed 1
=comments 1
=social 1

=abstract start

Multe programe Perl au de-a face cu fişiere text, cum ar fi fişiere de configurare or sau fişiere log, deci ca să facem aceaste cunoştiinţe utile este importantsă învăţăm despre lucrul cu fişiere într-un stadiu timpuriu.

Să vedem întâi cum putem scrie într-un fişier, pentru că asta pare a fi mai uşorde făcut.

=abstract end

Înainte de a putea scrie într-un fişier trebuie să-l deschizi: <b>open</b>, cerând sistemului de oparare (Windows, Linux, OSX, etc) să deschidă un canal
pentru ca programul să poată "vorbi cu" fişierul. Pentru asta Perl prevede
funcţia <hl>open</hl>, funcţie care are o sintaxă puţin mai ciudată.

<code lang="perl">
use strict;
use warnings;

my $filename = 'report.txt';
open(my $fh, '>', $filename) or die "Nu pot deschide fisierul '$filename' $!";
print $fh "Primul meu raport generat de Perl\n";
close $fh;
print "gata\n";
</code>

Acesta este un bun exemplu de lucru şi ne vom întoarce la el, dar să începem cu un exemplu mai simplu:

<h2>Exemplu Simplu</h2>

<code lang="perl">
use strict;
use warnings;

open(my $fh, '>', 'report.txt');
print $fh "Primul meu raport generat de Perl\n";
close $fh;
print "gata\n";
</code>

Aceasta necesită câteva explicaţii. Funcția <b>open</b> are 3 parametri.

Primul, <hl>$fh</hl>, este o variabilă de tip scalar pe care am definit-o în cadrul apelului funcției <hl>open()</hl>.
Am fi putut să o definim mai devreme, dar de obicei este mai curat în felul acesta, chiar dacă arată un pic mai ciudat la început. Al doilea parametru definește modul de deschidere al fișierului.
În acest caz, acesta este semnul mai-mare (<hl>&gt;</hl>) acesta înseamnă că deschidem fișierul pentru scriere.
Al treilea parametru este calea către fișierul pe care dorim să-l deschidem.

Când este apelată acestă funcție. pune un semn specila în variabila <hl>$fh</hl>. Se numește file-handle. Nu ne pasă prea mult care este conținutul aceste variabile; vom folosi acestă varibilă mai târziu. De reținut că ceea ce conține fișierul este numai pe disc și <b>NU</b> în variabila $fh.

Odată fișierul deschis putem folosi mânerul (file-handle) <hl>$fh</hl> intr-o comnadă <hl>print()</hl>.
Arată aproape la fel ca o comandă <hl>print()</hl> din celelelate părți ale tutorialului, dar acum, primul parametru este file-handle și <b>nu</b>(!) este virgulă după el.

Comanda print() de mai sus va  printa textul în fișier.

Apoi cu linia următoare închidem file-handle. Strict vorbind, acesta nu este
o cerință în Perl. Perl va închide automat și curat toate file-handles când variabilele ?goes out of scope?, sau cel mai târziu la terminarea execuției scriptului.
În orice caz, poate fi considerată o bună practică închiderea explicită a fișierelor.

Ultima linie <hl>print "gata\n"</hl> este doar pentru ca următorul exemplu să fie mai clar:

<h2>Gestionarea Erorilor</h2>

Să reluăm exemplul de mai sus și să înlocuim numele fișierului cu o cale inexistentă.
De exemplu scrie:

<code lang="perl">
open(my $fh, '>', 'some_strange_name/report.txt');
</code>

Dacă rulezi scriptul acum vei primi un mesaj de eroare:

<code>
print() on closed file-handle $fh at ...
done
</code>

De fapt acesta este doar o atenționare; scriptul rulează în continoare și de aceea vedem cuvântul "gata" printat pe ecran.

Chiar mai mult, am primit atenționarea doar pentru că am cerut explicit acest lucru cu comanda <hl>use warnings</hl>.
Încercați să comentați linia <hl>use warnings</hl> și veți vedea că scriptul va eșua operațiunea de creare a fișierului în mod silențios. Deci nu veți observa până când clientul, sau - mai rău - șeful vostru se va plânge.

Oricum este o problemă. Am încercat să deschidem un fișier. Am eșuat dar totuși am încercat să printăm ceva în el.

Mai bine am verifica dacă <hl>open()</hl> a fost cu succes înainte de a continua.

Din fericire comanda <hl>open()</hl> ea însăși returnează
<a href="http://perl5maven.com/boolean-values-in-perl">ADEVĂR la succes și FALS la eșec</a>, deci putem scrie așa:

<h2>Open or die</h2>

<code lang="perl">
open(my $fh, '>', 'some_strange_name/report.txt') or die;
</code>

Acesta este un idiom "standard": <b>open or die</b>. Foarte comun în Perl.

<hl>die</hl> este un apel de functie care va genera o excepție și astfel va termina execuția scriptului.

"open or die" este o expresie logică. Așa cum știți din părțile precedente ale tutorilaului, "or" scurt-circuitează în Perl (așa ca în multe alte limbaje).
Acesta înseamnă că dacă partea dreptă returneză ADEVĂR, știm că întrega expresie va fi ADEVĂRATĂ, și partea dreaptă nici nu mai este executată. Pe de altă partedacă partea stângă este FALSĂ atunci și partea dreaptă este executată și rezultatul ei devine rezultatul întregii expresii.

În acest caz folosim acest scurt-circuit pentru a scrie expresia.

Dacă comanda <hl>open()</hl> este cu succes atunci returnează ADEVĂR și astfel partea dreaptă nu mai este executată. Scriptul continuă cu linia următoare.

Dacă comanda <hl>open()</hl> eșuează, atunci va returna FALS. Atunci partea dreaptă a <hl>or</hl> este de asemenea executată. Generează o excepție, care termină scriptul.

În codul de mai sus nu verificăm rezultatul

the above code we don't check the actual resulting value of the logical expression.
We don't care. We only used it for the "side effect".

If you try the script with the above change you will get an error message:

<code>
Died at ...
</code>

and will NOT print "done".

<h2>Better error reporting</h2>

Instead of just calling die without a parameter, we could add some explanation of what happened.

<code lang="perl">
open(my $fh, '>', 'some_strange_name/report.txt')
  or die "Could not open file 'some_strange_name/report.txt'";
</code>

will print

<code>
  Could not open file 'some_strange_name/report.txt' ...
</code>

It is better, but at some point someone will try to change the path to the correct directory ...

<code lang="perl">
open(my $fh, '>', 'correct_directory_with_typo/report.txt')
  or die "Could not open file 'some_strange_name/report.txt'";
</code>

...but you will still get the old error message because they changed it
only in the open() call, and not in the error message.

It is probably better to use a variable for the filename:

<code lang="perl">
my $filename = 'correct_directory_with_typo/report.txt';
open(my $fh, '>', $filename) or die "Could not open file '$filename'";
</code>

Now we get the correct error message, but we still don't know why it failed.
Going one step further we can use <hl>$!</hl> - a built-in variable of Perl - to print
out what the operating system told us about the failure:

<code lang="perl">
my $filename = 'correct_directory_with_typo/report.txt';
open(my $fh, '>', $filename) or die "Could not open file '$filename' $!";
</code>

This will print

<code>
Could not open file 'some_strange_name/report.txt' No such file or directory ...
</code>

That's much better.

With this we got back to the original example.

<h2>Greater-than?</h2>

That greater-than sign in the open call might be a bit unclear,
but if you are familiar with command line redirection then this can be familiar to you too.
Otherwise just think about it as an arrow showing the direction of the data-flow:
into the file on the right hand side.

<h2>Non-latin character?</h2>

In case you need to handle characters that are not in the ASCII table, you'll probably want to save them
as UTF-8. To do that you need to tell Perl, you are opening the file with UTF-8 encoding.

<code lang="perl">
open(my $fh, '>:encoding(UTF-8)', $filename)
  or die "Could not open file '$filename'";
</code>
