=title Folosirea unei valori neiniţializate
=timestamp 2012-09-05T21:45:56
=indexes undef, uninitialized value, $|, warnings, buffering
=status show
=original use-of-uninitialized-value
=books beginner_book
=author szabgab
=translator stefansbv
=archive 1
=comments 1
=social 1

=abstract start

Acesta este una dintre cele mai comune avertizări (în lb. en:
warning) pe care le întâlneşti când rulezi cod Perl.

Este o avertizare, nu va opri execuţia programului şi este generată
numai dacă avertizările sunt pornite. Ceea ce este recomandat.

Cea mai uzuală cale de a porni avertizările este prin includerea unei
comenzi <hl>use warnings;</hl> la începutul scriptului sau al
modulului.

=abstract end

Calea mai veche metodă este prin adăugarea fanionului <hl>-w</hl> pe
linia "sh-bang". În mod uzual acesta arată astfel:

<hl>#!/usr/bin/perl -w</hl>

Sunt câteva diferenţe, dar cum <hl>use warnings</hl> este disponibilă de 12 ani,
nu sunt motive pentru a o evita. Cu alte cuvinte:

Întodeauna <hl>use warnings;</hl>!

Să ne întoarcem la mesajul de avertizare pe care am dorit să-l
explicăm.

<h2>O explicaţie rapidă</h2>

<code>
Use of uninitialized value $x in say at perl_warning_1.pl line 6.
</code>

Acesta înseamnă că variabile <hl>$x</hl> nu are valoare (valoarea ei
este de fapt valoarea specială <hl>undef</hl>).

Adică nu a avut niciodată o valoare (alta decât undef), sau la un
moment dat a primit valoarea <hl>undef</hl>.

Ar trebui să examinezi liniile de cod unde variabila a primit ultima
dată o nouă valoare sau ar trebui să încerci să înţelegi de ce acea
bucăţică de cod nu a mai ajuns să fie executată.

<h2>Un exemplu simplu</h2>

Exemplul următor va genera o astfel de avertizare.

<code lang="perl">
use warnings;
use strict;
use 5.010;

my $x;
say $x;
</code>

Perl este foarte amabil, îţi spune care fişier a generat avertizarea
şi la ce linie.

<h2>Doar o avertizare</h2>


Aşa cum am menţionat, acesta este doar o avertizare. Dacă scriptul are
mai multe comenzi după cea cu <hl>say</hl>, acestea vor fi executate:

<code lang="perl">
use warnings;
use strict;
use 5.010;

my $x;
say $x;
$x = 42;
say $x;
</code>

Acesta va printa

<code>
Use of uninitialized value $x in say at perl_warning_1.pl line 6.

42
</code>

<h2>Confusing output order</h2>

Beware though, if your code has print statements before the line
generating the warning, like in this example:

<code lang="perl">
use warnings;
use strict;
use 5.010;

print 'OK';
my $x;
say $x;
$x = 42;
say $x;
</code>

the result might be confusing.

<code>
Use of uninitialized value $x in say at perl_warning_1.pl line 7.
OK
42
</code>

Here, 'OK', the result of the <hl>print</hl> is seen <b>after</b>
the warning, even though it was called <b>before</b> the
code that generated the warning.

This strangeness is the result of <hl>IO buffering</hl>.
By default Perl buffers STDOUT, the standard output channel,
while it does not buffer STDERR, the standard error channel.

So while the word 'OK' is waiting for the buffer to be flushed,
the warning message already arrives to the screen.

<h2>Turning off buffering</h2>

In order to avoid this you can turn off the buffering of STDOUT.

This is done by the following code: <hl>$| = 1;</hl>
at the beginning of the script.


<code lang="perl">
use warnings;
use strict;
use 5.010;

$| = 1;

print 'OK';
my $x;
say $x;
$x = 42;
say $x;
</code>

<code>
OKUse of uninitialized value $x in say at perl_warning_1.pl line 7.
42
</code>

(The warning is on the same line as the <b>OK</b> because we have not printed a newline
<hl>\n</hl> after the OK.)

<h2>The unwanted scope</h2>

<code lang="perl">
use warnings;
use strict;
use 5.010;

my $x;
my $y = 1;

if ($y) {
  my $x = 42;
}
say $x;
</code>

This code too produces <hl>Use of uninitialized value $x in say at perl_warning_1.pl line 11.</hl>

I have managed to make this mistake several times. Not paying attention I used <hl>my $x</hl>
inside the <hl>if</hl> block, which meant I have created another $x variable,
assigned 42 to it just to let it go out of the scope at the end of the block.
(The $y = 1 is just a placeholder for some real code and some real condition.
It is there only to make this example a bit more realistic.)

There are of course cases when I need to declare a variable inside an if block, but not always.
When I do that by mistake it is painful to find the bug.
