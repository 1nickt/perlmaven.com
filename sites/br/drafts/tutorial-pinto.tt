=title Pinto -- O Seu CPAN Personalizado
=timestamp 2013-03-15T07:30:01
=indexes cpan, pinto
=status show
=original pinto tutorial 
=author szabgab
=translator leprevost
=index 1
=archive 1
=feed 1
=comments 1
=social 1

=abstract start

<i>
Este é um artigo escrito por um convidado, <a href="">Jeffrey Ryan Thalhammer</a>, autor do projetos Pinto
e Perl::Critic.
Até o dia 7 de Maio, Jeff estará <a href="https://www.crowdtilt.com/campaigns/specify-module-version-ranges-in-pint">levantando fundos</a>
para financiar o desenvolvimento do elemento que irá permitir você a <b>especificar uma série de diferentes versões pelo Pinto.</b>
</i>

Uma das melhores coisas no Perl são os módulos <i>open source</i> que estão disponíveis pelo CPAN.
Mas mantê-los é um trabalho árduo. Toda semana centenas de novos lançamentos ocorrem e você 
nunca sabe quando uma nova versão de um módulo pode introduzir um <i>bug</i> que quebrará a sua aplicação.

=abstract end

Uma estratégia para resolver este tipo de prolema é construir seu próprio repositório
do CPAN, que conterá apenas as versões dos módulos que você deseja. Dessa forma você pode utilizar 
o construtor do CPAN para instalar módulos a partir do seu próprio repositório sem ficar
exposto ao CPAN público.

Através dos anos eu construí vários repositórios personalizdos do CPAN utilizando ferramentas como
<a href="https://metacpan.org/module/CPAN::Mini">CPAN::Mini</a> e <a href="https://metacpan.org/module/CPAN::Site">CPAN::Site</a>.
Mas eles sempre me pareceram desajeitados e nunca estive satisfeito com eles.
A alguns anos atrás, fui contratado por um cliente para construi outro repositório personalizado
do CPAN. Mas desta vez eu tive a oportunidade de começar a partir do zero. O resultado disso tudo
é o projeto Pinto.

<a href="https://metacpan.org/module/Pinto">Pinto</a> é uma ferramenta robusta
para criar e manipular repositórios CPAN personalizados.
Ele possui várias características poderosas que irão, de forma segura, lhe ajudar
a gerenciar todos os módulos Perl cuja sua aplicação seja dependente.
Este tutorial irá lhe ajudar a criar um repositório CPAN personalizado com o Pinto
e ao mesmo tempo, demonstrar algumas de suas características.

<h2>Instalando o Pinto</h2>

O módulo Pinto está disponível pelo CPAN e pode ser instalado como qualquer
outro módulo utilizando o cpan ou o <hl>cpanm</hl>. Porém o projeto Pinto é
mais uma aplicação do que uma biblioteca. É uma ferramenta que você utiliza
para gerenciar o código de suas aplicações, isso sem se tornar parte de sua 
aplicação. Portanto eu recomendo instalar o Pinto como um projeto 
independente através desses dois comandos:

<code>
curl -L http://getpinto.stratopan.com | bash
source ~/opt/local/pinto/etc/bashrc
</code>

Isso irá instalar o Pinto em <hl>~/opt/local/pinto</hl> e adicionará
os diretórios necessários em seu <hl>PATH</hl> e <hl>MANPATH</hl>. Todo o conteúdo
é localizado, isso significa que ao instalar o Pinto não irá afetar o seu ambiente de
desenvolvimento, e da mesma forma, o seu ambiente de desenvolvimento também não irá
afetar o Pinto.

<h2>Explorando o Projeto Pinto</h2>

Assim como quando explora uma ferramenta nova, a primeira coisa que você deverá saber
é como buscar ajuda:

<code>
pinto commands            # Apresenta uma lista de comandos disponíveis
pinto help <COMMAND>      # Apresenta um sumário de opções e argumentos para o <COMMAND>
pinto manual <COMMAND>    # Apresenta o manual completo para <COMMAND>
</code>

O projeto também é instalado com outra documentação, incluindo um tutorial e um
guia rápido para referências. Você pode acessar esses documentos através dos comandos:

<code>
man Pinto::Manual::Introduction  # Explica os conceitos básicos do projeto
man Pinto::Manual::Installing    # Sugestões para a instalação
man Pinto::Manual::Tutorial      # Um guia narrativo pelo projeto
man Pinto::Manual::QuickStart    # Um sumário de comandos comuns
</code>

<h2>Criando o Reositório</h2>

O primeiro passo ao utilizar o projeto Pinto é criar um repositório
através do comando <hl>init</hl>:

<code>
pinto -r ~/repo init
</code>

O comando criará um novo repositório no diretório <hl>~/repo</hl>.
Se o diretório não existir, ele será criado para você. Se ele já existir
então deve esatr vazio.

A opção -r (ou --root) especifica aonde o repositório está. Isso é necessário
para todo comando. Mas se você se cansar de digitar isso sempre, você poderá
configurar a variável de ambiente <hl>PINTO_REPOSITORY_ROOT</hl> para que 
referencie o seu repositório, dessa forma você pode omitir o -r.

<h2>Inspecionando O Repositorio</h2>

Agora que você já possui um repositório, vamos ver o que há por dentro.
Para ver o seu conteúdo, use o comando <hl>list</hl>:

<code>
pinto -r ~/repo list
</code>

A partir desse ponto, a listagem retornará vazia porque não há nada no repositório.
Mas você irá utilizar o comando <hl>list</hl> várias vezes durante o tutorial.

<h2>Adicioando Módulos do CPAN</h2>

Suponha que você esteja trabalhando em uma aplicação My-App que contém
um módulo My::App, e que dependa do módulo URI. Você pode trazer o módulo 
URI para o seu repositório utilizando o comando <hl>pull</hl>:

<code>
pinto -r ~/repo pull URI
</code>

Você será questionado a descrever uma mensagem que descreva o motivo
de tal mudança em seu repositório. No topo da mesagem inclui uma mensagem simples
que você poderá editar. O rodapé da mensagem mostrará exatamente quais módulos
foram adicionados. 
Salve o arquivo e feche o editor de texto quando terminar.

Agora você deverá ter o módulo URI em seu repositório Pinto. Então vamos
ver o que realmente temos. Novamente use o comando <hl>list</hl> para
ver o conteúdo do repositório:

<code>
pinto -r ~/repo list
</code>

Dessa vez a listagem irá se parecer com isso:

<code>
rf  URI                            1.60  GAAS/URI-1.60.tar.gz
rf  URI::Escape                    3.31  GAAS/URI-1.60.tar.gz
rf  URI::Heuristic                 4.20  GAAS/URI-1.60.tar.gz
...
</code>

Você pode observar que o módulo URI foi adicionado ao repositório, assim como
os requisitos para o URI, e todos os requisitos dos requisitos, e assim
por diante.

<h2>Adicionando Módulos Particulares</h2>

Agora suponha que você terminou o seu trabalho no módulo My-App e você está
pronto para liberar a primeira versão. Utilizando sua ferramenta preferida de
instalação (e.g. ExUtils::MakeMaker, Module::Builder, Module::Install, etc.)
você cria o pacote da sua distribuição como My-App-1.0.tar.gz. Agora você
pode colocar a distribuição no repositório Pinto com o comando <hl>add</hl>:

<code>
$> pinto -r ~/repo add path/to/My-App-1.0.tar.gz
</code>

Novamente será necessário descrever em uma mensagem as mudanças realizadas.
Agora, quando você lista o conteúdo do repositório, verá o módulo My::App
mostrando você como autor da distribuição.

<code>
rl  My::App                         1.0  JEFF/My-App-1.0.tar.gz
rf  URI                            1.60  GAAS/URI-1.60.tar.gz
rf  URI::Escape                    3.31  GAAS/URI-1.60.tar.gz
rf  URI::Heuristic                 4.20  GAAS/URI-1.60.tar.gz
...
</code>


<h2>Instalando Módulos</h2>

Now that you have your modules inside the Pinto repository, the next
step is to actually build and install them somewhere.  Under the hood,
a Pinto repository is organized just like a CPAN repository, so it is
fully compatible with cpanm and any other Perl module installer.  All
you have to do is point the installer at your Pinto repository:

<code>
cpanm --mirror file://$HOME/repo --mirror-only My::App
</code>

That will build and install My::App using *only* the modules in your
Pinto repository.  So you'll get exactly the same versions of those
modules every time, even if the module is removed or upgraded on the
public CPAN.

With cpanm, the --mirror-only option is important because it prevents
cpanm from falling back to the public CPAN when it can't find a module
in your repository.  When that happens, it usually means that some
distribution in the repository doesn't have all the correct
dependencies declared in its META file.  To fix the problem, just use
the <hl>pull</hl> command to fetch any modules that are  missing.


<h2>Upgrading Modules</h2>

Suppose that several weeks have passed since you first released My-App
and now URI version 1.62 is available on the CPAN.  It has some
critical bug fixes that you'd like to get.  Again, we can bring that
into the repository using the <hl>pull</hl> command.  But since your
repository already contains a version of URI, you must indicate that
you want a <b>newer</b> one by specifying the minimum version that you
want:

<code>
pinto -r ~/repo pull URI~1.62
</code>

If you look at the listing again, this time you'll see the newer
version of URI (and possibly other modules as well):

<code>
rl  My::App                         1.0  JEFF/My-App-1.0.tar.gz
rf  URI                            1.62  GAAS/URI-1.62.tar.gz
rf  URI::Escape                    3.38  GAAS/URI-1.62.tar.gz
rf  URI::Heuristic                 4.20  GAAS/URI-1.62.tar.gz
...
</code>

If the new version of URI requires any upgraded or additional
dependencies, those will be in the repository too.  And when you
install My::App, now you'll get version 1.62 of URI.

<h2>Working With Stacks</h2>

Thus far, we've treated the repository as a singular resource.  So
when we upgraded URI in the last section, it affected every person and
every application that might have been using the repository.  But this
kind of broad impact is undesirable.  You would prefer to make changes
in isolation and test them before forcing everyone else to upgrade.
This is what stacks are designed for.

All CPAN-like repositories have an index which maps the latest version
of each module to the archive that contains it.  Usually, there is
only one index per repository.  But in a Pinto repository, there can
be many indexes.  Each of these indexes is called a <b>"stack"</b>.  This
allows you to create different stacks of dependencies within a single
repository.  So you could have a "development" stack and a
"production" stack, or a "perl-5.8" stack and a "perl-5.16" stack.
Whenever you add or upgrade a module, it only affects one stack.

But before going further, you need to know about the default stack.
For most operations, the name of the stack is an optional parameter.
So if you do not specify a stack explicitly, then the command is
applied to whichever stack is marked as the default.

In any repository, there is never more than one default stack.  When
we created this repository, a stack called "master" was also created and
marked as the default.  You can change the default stack or change the
name of a stack, but we won't go into that here.  Just remember that
"master" is the name of the stack that was created when the repository
was first initialized.

<h3>Creating A Stack</h3>

Suppose your repository contains version 1.60 of URI but version 1.62
has been released to the CPAN, just like before.  You want to try
upgrading, but this time you're going to do it on a separate stack.

Thus far, everything you've added or pulled into the repository has
gone into the "master" stack.  So we're just going to make a clone
of that stack using the <hl>copy</hl> command:

<code>
pinto -r ~/repo copy master uri_upgrade
</code>

This creates a new stack called "uri_upgrade".  If you want to see the
contents of that stack, just use the <hl>list</hl> command with the "--stack"
option:

<code>
pinto -r ~/repo list --stack uri_upgrade
</code>

The listing should be identical to the "master" stack:

<code>
rl  My::App                         1.0  JEFF/My-App-1.0.tar.gz
rf  URI                            1.60  GAAS/URI-1.60.tar.gz
...
</code>

<h3>Upgrading A Stack</h3>

Now that you've got a separate stack, you can try upgrading URI.  Just
as before, you'll use the <hl>pull</hl> command.  But this time, you'll tell
Pinto to pull the modules into the "uri_upgrade" stack:

<code>
pinto -r ~/repo pull --stack uri_upgrade URI~1.62
</code>

We can compare the "master" and "uri_upgrade" stacks using the "diff"
command:

<code>
pinto -r ~/repo diff master uri_upgrade

+rf URI                                              1.62 GAAS/URI-1.62.tar.gz
+rf URI::Escape                                      3.31 GAAS/URI-1.62.tar.gz
+rf URI::Heuristic                                   4.20 GAAS/URI-1.62.tar.gz
...
-rf URI                                              1.60 GAAS/URI-1.60.tar.gz
-rf URI::Escape                                      3.31 GAAS/URI-1.60.tar.gz
-rf URI::Heuristic                                   4.20 GAAS/URI-1.60.tar.gz
</code>

The output is similar to the diff(1) command. Records starting with a
"+" were added and those starting with a "-" were removed.  You can
see that modules from the URI-1.60 distribution have been replaced
with modules from the URI-1.62 distribution.

<h3>Installing From A Stack</h3>

Once you have new modules on the "uri_upgrade" stack, you can try
building your application by pointing cpanm at the stack.  Each stack
is just a subdirectory inside the repository, so all you have to do
is add it to the URL:

<code>
cpanm --mirror file://$HOME/repo/stacks/uri_upgrade --mirror-only My::App
</code>

If all the tests pass, then you can confidently upgrade URI to version
1.62 in the "master" stack as well by using the <hl>pull</hl> command.  Since
"master" is the default stack, you can omit the "--stack" paramter:

<code>
pinto -r ~/repo pull URI~1.62
</code>

<h2>Working With Pins</h2>

Stacks are a great way to test the effect of changing your application
dependencies.  But what if the tests didn't pass?  If the problem lies
within My-App and you can quickly correct it, you might just modify
your code, release version 2.0 of My-App, and then proceed to upgrade
URI on the "master" stack.

But if the issue is a bug in URI or it will take a long time to fix
My-App, then you have a problem.  You don't want someone else to
upgrade URI, nor do you want it to be upgraded inadvertently to
satisfy some other prerequisite that My-App may have.  Until you know
the problem is fixed, you need to prevent URI from being upgraded.
This is what pins are for.

<h3>Pinning A Module</h3>

When you pin a module, that version of the module is forced to stay in
a stack.  Any attempt to upgrade it (either directly or via another
prerequisite) will fail.  To pin a module, use the <hl>pin</hl> command:

<code>
pinto -r ~/repo pin URI
</code>

If you look at the listing for the "master" stack again, you'll see
something like this:

<code>
...
rl  My::App                         1.0  JEFF/My-App-1.0.tar.gz
rf! URI                            1.60  GAAS/URI-1.60.tar.gz
rf! URI::Escape                    3.31  GAAS/URI-1.60.tar.gz
...
</code>

The "!" near the beginning of a record indicates the module has been
pinned.  If anyone attempts to upgrade URI or a add distribution that
requires a newer version of URI, then Pinto will give a warning and
refuse to accept the new distributions.  Notice that every module in
the URI-1.60 distribution has been pinned, so it is impossible to
partially upgrade a distribution (this situation could happen when a
module moves into a different distribution).

<h3>Unpinning A Module</h3>

After a while, suppose you fix the problem in My-App or a new version
of URI is released that fixes the bug.  When that happens, you can
unpin URI from the stack using the <hl>unpin</hl> command:

<code>
pinto -r ~/repo unpin URI
</code>

At this point you're free to upgrade URI to the latest version
whenever you're ready.  Just as with pinning, when you unpin a module
it unpins every other module it the distribution as well.

<h2>Using Pins And Stacks Together</h2>

Pins and stacks are often used together to help manage change during
the development cycle.  For example, you could create a stack called
"prod" that contains your known-good dependencies.  At the same time,
you could also create a stack called "dev" that contains experimental
dependencies for your next release.  Initially, the "dev" stack is
just a copy of the "prod" stack.

As development proceeds, you may upgrade or add several modules on the
"dev" stack.  If an upgraded module breaks your application, then
you'll place a pin in that module on the "prod" stack to signal that
it shouldn't be upgraded.

<h3>Pins and Patches</h3>

Sometimes you may find that a new version of a CPAN distribution has a
bug but the author is unable or unwilling to fix it (at least not
before your next release is due).  In that situation, you may decide
to make a local patch of the CPAN distribution.

So suppose that you forked the code for URI and made a local version
of the distribution called URI-1.60_PATCHED.tar.gz.  You can add it to
your repository using the <hl>add</hl> command:

<code>
pinto -r ~/repo add path/to/URI-1.60_PATCHED.tar.gz
</code>

In this situation, it is wise to pin the module as well, since you do
not want it to be upgraded until you are sure that the new version
from CPAN includes your patch or the author has fixed the bug by other
means.

<code>
pinto -r ~/repo pin URI
</code>

When the author of URI releases version 1.62, you'll want to test it
before deciding to unpin from your locally patched version.  Just as
before, this can be done by cloning the stack with the <hl>copy</hl> command.
Let's call it the "trial" stack this time:

<code>
pinto -r ~/repo copy master trial
</code>

But before you can upgrade URI on the "trial" stack, you'll have to
unpin it there:

<code>
pinto -r ~/repo unpin --stack trial URI
</code>

Now you can proceed to upgrade URI on the stack and try building
My::App like this:

<code>
pinto -r ~/repo pull --stack trial URI~1.62
cpanm --mirror file://$HOME/repo/stacks/trial --mirror-only My::App
</code>

If all goes well, remove the pin from the "master" stack and pull the
newer version of URI back into it.

<code>
pinto -r ~/repo unpin URI
pinto -r ~/repo pull URI~1.62
</code>

<h2>Reviewing Past Changes</h2>

As you've probably noticed by now, each command that changes the state
of a stack requires a log message to describe it.  You can review
those messages using the <hl>log</hl> command:

<code>
pinto -r ~/repo log
</code>

That should display something like this:

<code>
revision 4a62d7ce-245c-45d4-89f8-987080a90112
Date: Mar 15, 2013 1:58:05 PM
User: jeff

     Pin GAAS/URI-1.59.tar.gz

     Pinning URI because it is not causes our foo.t script to fail

revision 4a62d7ce-245c-45d4-89f8-987080a90112
Date: Mar 15, 2013 1:58:05 PM
User: jeff

     Pull GAAS/URI-1.59.tar.gz

     URI is required for HTTP support in our application

...
</code>

The header for each message shows who made the change and when it happened.
It also has a unique identifier similar to Git's SHA-1 digests.  You can
use these identifiers to see the diffs between different revisions or to
reset the stack back to a prior revision [NB: this feature is not actually
implemented yet].

<h2>Conclusion</h2>

In this tutorial, you've seen the basic commands for creating a Pinto
repository and populating it with modules.  You've also seen how to
use stacks and pins to manage your dependencies in the face of some
common development obstacles.

Each command has several options that were not discussed in this
tutorial, and there are some commands that were not mentioned here at
all.  So I encourage you to explore the manual pages for each command
and learn more.

