=title Scalar and List context in Perl, the size of an array
=title 펄에서의 스칼라 그리고 리스트 문맥, 배열의 사이즈
=timestamp 2013-04-10T11:45:56
=indexes scalar, list, array, size, length, context, Perl
=status show
=books beginner_book
=author szabgab
=translator kangyunchang
=index 1
=archive 1
=feed 1
=comments 1
=social 1

=abstract start

<a href="/perl-tutorial">펄 튜토리얼</a>에서 우리는 펄이 문맥에 민감하다는것을 살펴보고자 합니다

In English, as in most of the other spoken languages, words can have multiple meanings.
For example the word "left" has several meanings:

영어에서는, 대부분의 다른언어와 마찬가지로 , 'left'라는 단어는 많은 뜻을 가질수 있습니다.
예를들면 'left'는 여러가의 뜻이 있습니다:

I left the building.

I turned left at the building.

We understand which is the correct meaning by the sentences around the word.
This is called the context.

우리는 단어 주변의 문장들을 통해 정확한 의미를 알 수 있습니다.
이것을 문맥이라 부릅니다.

Perl 5 is similar. Words, function calls, and other expressions can have
different meaning depending on context. It makes learning harder, but provides
more expressiveness.

Perl 5도 위와 유사합니다. 단어들, 함수호출들, 그리고 다른 표현식들이 
문맥에 의존하면서 서로 다른 뜻을 가질 수 있습니다. 열심히 학습하면 많은 표현식을 
사용 할 수 있습니다.
=abstract end

There are two major contexts in Perl: SCALAR and LIST context.
펄에서는 2개의 중요한 문맥이 있습니다: 스칼라 그리고 리스트 문맥.

<h2>리스트 문맥에서의 배열</h2>
Let's see an example:
다음예제를 봅시다:

<code lang="perl">
my @words = ('Foo', 'Bar', 'Baz');
my @names = @words;
</code>

After the above assignment <hl>@names</hl> contains a copy of the values that were in <hl>@words</hl>;
위에서는 <h1>@names</h1>에 리스트의 내용을 할당한 후 <hl>@words</hl>에 값들을 복사합니다;

Assignment of an array to another array copies the content of the array.
배열의 내용은 다른 배열에서 복사를 하여 할당 합니다.

<h2>Array in SCALAR context</h2>
<h2>스칼라 문맥에서의 배열</h2>

<code lang="perl">
my @words = ('Foo', 'Bar', 'Baz');
my $people =  @words;
</code>

This time we assigned the <hl>@words</hl> array to <hl>$people</hl>, a scalar variable.
이 시점에 <hl>$people</hl> 스칼라 변수에, <h1>@words</h1> 배열이 할당 됩니다.

Other languages would behave differently, but in Perl this
assignment places <b>the number of elements of the array</b>
in the scalar variable.

다른 언어들은 다르게 동작할 것이지만, 펄은 배열의 요소의 수를 스칼라 변수에 할당 합니다.

That's arbitrary, and in the above case not very useful either, but there are a number of other
cases when this behavior can be very useful.

임의로 위에 케이스는 매우 유용하지 않은 경우지만 매우 유용한 케이스도 여러가지가 있습니다.

<h2>SCALAR and LIST context</h2>
<h2>리스트 문맥에서의 스칼라</h2>

The above two are called SCALAR and LIST context. They mean if the expectation is
to get a single value (in SCALAR context), or if multiple values are expected (LIST context).
In LIST context the number of values can be 0, 1, 2, or any other number.

위에는 2개는 스칼라와 리스트 문맥이라 부릅니다. 그것은 (스칼라 문맥에서) 하나의 값을 얻을 경우를 기대하고, 
여러개의 값이 예상되는경우(리스트 문맥)를 기대합니다.
리스트 문맥에서 값의 수는 0, 1, 2, 또는 어느 숫자가 될 수도 있습니다.

<h2>The context of the if statement</h2>
<h2>if 문의 문맥</h2>

Look at this example:
이번 예제를 봅시다:

<code lang="perl">
my @words = ('Foo', 'Bar', 'Baz');

if (@words) {
   say "There are some words in the array";
}
</code>

Inside the the condition part of the <hl>if</hl> statement we are
expecting exactly one value. That must be SCALAR context then.

내부조건에 <hl>if</hl>문장은 정확하게 하나의 값을 기대합니다.
반드시 스칼라 문맥이어야 합니다.

By now we know that the value of an array in SCALAR context is the number
of elements. We also know that this is 0 (that is <a href="/boolean-values-in-perl">FALSE</a>)
when the array is empty, and some other positive number (that is <a href="/boolean-values-in-perl">TRUE</a>),
when the array has 1 or more elements.

지금쯤 우리는 스칼라 문맥에서 배열의 값은 요소의 수라는 것을 알고 있습니다.
우리는 역시 배열이 비어 있을때 0(that is <a href="/boolean-values-in-perl">FALSE</a>)인 것을 알고, 다른 어떤 양수
(that is <a href="/boolean-values-in-perl">TRUE</a>), 배열에 1개 또는 여러개의 요소가 있을때를 알고 있습니다.

So because of that arbitrary decision above, the code <hl>if (@words)</hl>
checks if there is any content in the array and fails if the array is empty.
그렇기 때문에 위의 임의의 결정은 <hl>if (@words)</hl>코드에서 체크를 합니다
만약 배열이 비어었다면 실패를 그리고 배열에 어떤 내용이 있을경우를 체크하는 코드 입니다.

Turning the if-statement around  <hl>if (! @words)</hl> will be true
if the array is empty.
만약 배열이 비어 있으면 if 구문은 true가 됩니다.

<h2>SCALAR and LIST context</h2>
<h2>스칼라 그리고 리스트 문맥</h2>

In the <a href="/the-year-19100">previous episode</a> we saw how <hl>localtime()</hl>
behaves in SCALAR and LIST context, and now we saw how an array behaves in SCALAR and LIST context.
<a href="/the-year-19100">이전문장</a>에서 우리는 <hl>localtime()</hl>에서 스칼라와 리스트문맥에서 
어떻게 동작하는지 보았고, 지금 우리는 스칼라와 리스트 문맥에서 배열이 동작하는 방법을 보았습니다.

There is no general rule about context, and you will have to learn the specific cases,
but usually they are quite obvious. In any case, when you look up a function using
<a href="/core-perl-documentation-cpan-module-documentation">perldoc</a>,
you will see an explanation of this for each function.
At least in the cases where the SCALAR and LIST contexts yield different results.
이 문맥에 대한 더 일반적인 규칙은 없습니다, 그리고 특별한 경우를 배워야 합니다, 
그리고 일반적으로 리스트 문맥은 명백합니다.
어떤 경우에 우리는 <a href="/core-perl-documentation-cpan-module-documentation">perldoc</a>을 사용하여 함수를 볼떄
우리는 각 함수의 기능의 설명을 볼수 있습니다.
최소한 이경우는 스칼라 그리고 리스트 문맥이 서로 다른 결과를 볼수 있습니다.

We should now look at a few more examples for expressions in Perl,
and what kind of context they create.
우리는 펄에서 몇개의 예제를 보고 문맥이 어떤 종류로 만들어 졌는지 볼수 있어야 합니다.

<h2>Creating SCALAR context</h2>
<h2>스칼라 문맥 만들기</h2>

We already saw that no matter what you assign to a scalar variable that thing will be in SCALAR context.
Let's describe it this way:
우리는 스칼라 문맥에서 스칼라 변수의 할당과 관계없다는 것을 보았습니다. 
위와 같은 방법을 설명 합니다:

<code>
$x = SCALAR;
</code>

Because individual elements of an array are also scalars, assignment to them also creates SCALAR context:
배열의 각각의 요소도 역시 스칼라 이고, 배열에게 할당은 스칼라 문맥을 만듭니다.

<code>
$word[3] = SCALAR;
</code>

Concatenation expects two strings on either side so it creates SCALAR context on both sides:
양쪽에 두개의 스칼라 문맥을 만들고 연결 연산자는 두개의 문자열을 기대 합니다:

<code>
"string" . SCALAR;
</code>

but also
뿐만 아니라

<code>
SCALAR . "string"
</code>

So
역시

<code lang="perl">
my @words = ('Foo', 'Bar', 'Baz');
say "Number of elements: " . @words;
say "It is now " . localtime();
</code>

Will print
아래와 같이 결과가 나타납니다.

<code>
Number of elements: 3
It is now Thu Feb 30 14:15:53 1998
</code>

Numerical operators usually expect two numbers - two scalars - on either side.
So numerical operators create SCALAR context on both sides:
수치 연산자는 일반적으로 2개의 숫자를 기대 합니다 - 두개의 스칼라 - 양쪽에.
그래서 수치 연산자는 스칼라 문맥을 양쪽에 만듭니다.

<code>
5 + SCALAR;

SCALAR + 5;
</code>

<h2>Creating LIST context</h2>
<h2>리스트 문맥 만들기</h2>

There are constructs that create LIST context:
리스트 문맥의 구조를 만들기: 

Assignment to an array is one of them:
배열에 할당하는것은 그중 하나입니다:

<code>
@x = LIST;
</code>

Assignment to a list is another place:
다른 리스트에 할당 합니다:

<code>
($x, $y) = LIST;
</code>

Even if that list only has one element:
하나의 요소를 가지고 있는 리스트 조차도 마찬가입니다:

<code>
($x) =  LIST;
</code>

That brings us to an important issue that can easily trick people:
사용자를 쉽게 속일수 있는 중요한 문제를 우리에게 알려줍니다:

<h2>When are the parentheses significant?</h2>
<h2>가로를 사용할 때가 중요하다?</h2>

<code lang="perl">
use strict;
use warnings;
use 5.010;

my @words = ('Foo', 'Bar', 'Baz');

my ($x) = @words;
my $y   = @words;

say $x;
say $y;
</code>

the output is:
결과:

<code>
Foo
3
</code>

This is one of the few places where the parentheses are very important.
괄호는 매우 중요한 몇가지 장소중 하나 입니다.

In the first assignment <hl>my ($x) = @words;</hl> we assigned
to a <b>list</b> of scalar variable(s).
That created LIST context on the right hand side. That means the <b>values</b>
of the array were copied to the list on the left hand side. Because there was only
one scalar, the first element of the array got copied and the rest not.
첫번째로 스칼라 변수의 리스트에<b>list</b> <hl>my ($x) = @words;</hl> 할당 됩니다.
오른쪽에 리스트 문맥을 만들었습니다. 즉, 배열의 값은<b>values</b> 왼쪽에 복사 됩니다.
왜냐하면 오직 하나의 스칼라이고, 배열의 첫번쨰 요소가 있었기 때문에 하나만 복사하고 나머지는 무시합니다.

In the second assignment <hl>my $y   = @words;</hl> we assigned <b>directly</b> to
a scalar variable. That created SCALAR context on the right hand side. An array in
SCALAR context returns the number of elements in it.
This will be very important when you look at
<a href="/subroutines-and-functions-in-perl">passing parameters to functions</a>.

<h2>Forcing SCALAR context</h2>

Both <hl>print()</hl> and <hl>say()</hl> create LIST context for their parameters.
So what if you would like to print the number of elements in an array?
What if you'd like to print the nicely formatted date that is returned by <hl>localtime()</hl>?

Let's try this:
다음 방법을 봅시다:

<code lang="perl">
use strict;
use warnings;
use 5.010;

my @words = ('Foo', 'Bar', 'Baz');

say @words;
say localtime();
</code>

And the output is
그리고 결과를 봅니다.

<code>
FooBarBaz
3542071011113100
</code>
The former is somehow understandable, these are the values in the array smashed together.
배열은 어떻게든 값을 알 수 있습니다.

The second one is confusing. It is NOT the same as the result of the <hl>time()</hl>
function one might think. It is actually the 9 numbers returned by the <hl>localtime()</hl>
function in LIST context. If you don't remember, check it out in the episode about
<a href="/the-year-19100">the year of 19100</a>.
두번째는 혼란스럽습니다.  <hl>time()</hl>함수는 우리가 생각하는 결과와 다릅니다.

The solution is to use the <hl>scalar()</hl> function that  will create SCALAR context for its parameter.
Actually that's the whole job of the <hl>scalar()</hl> function. Some people might think about it as
<b>casting</b> from plural to singular, even though I think this word is not used often in Perl-land.
해결방법은 스칼라 함수를 사용하여 매개변수를 만드는 것입니다.
실제로 이것이 스칼라 함수의 작업의 전부 입니다. 
어떤 사람들은 <b>casting</b> 처럼 복수와 단수로 생각하더라도 펄은 자주 사용하지 않습니다.

<code lang="perl">
say scalar @words;
say scalar localtime();
</code>

And the output will be:
결과는 아마 아래와 같을것입니다:

<code>
3
Mon Nov  7 21:02:41 2011
</code>

<h2>Length or size of an array in Perl</h2>
<h2>펄에서 배열의 사이즈와 길이</h2>

In a nutshell, if you would like to get the size of an array in Perl you can use
the <hl>scalar()</hl> function to force it in SCALAR context and return the size.
간단히 요약하자면, 펄에서 <hl>scalar()</hl>함수를 강제로 배열에서 사용하면 스칼라 문맥이되어
사이즈를 리턴할 수 있습니다.

<h2>The tricky way</h2>
<h2>교묘한 방법</h2>

Sometimes you might see code like this:
가끔 당신은 다음과 같은 코드를 볼 수 있습니다:

<code lang="perl">
0 + @words;
</code>

This is basically a tricky way to get the size of the array. The <hl> + </hl> operator
creates SCALAR context on both sides. An array will return its size in SCALAR context.
Adding 0 to it does not change the number, so the above expression returns the size of the array.
이것은 기본적으로 배열의 사이즈를 얻을수 있는 교묘한 방법입니다. <hl> + </hl> 연산자는
양쪽에 스칼라 문맥을 만듭니다. 배열은 스칼라 문맥에서 크기를 반환합니다. 여기에 0을 추가하면 
배열의 사이즈는 변하지 않고 결과를 반환 합니다.

I'd recommend writing the slightly longer but clearer way using the <hl>scalar</hl> function.
<hl>scalar</hl>함수를 사용하는 것을 권장합니다.
