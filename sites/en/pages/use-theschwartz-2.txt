=title How To Use TheSchwartz Perl Module (Part 2)
=timestamp 2019-12-28T12:00:00
=description How to use TheSchwartz Perl module (Part 2)
=indexes FreeBSD, PostgreSQL, cpan, cpanm, TheSchwartz, TheSchwartz::Worker, TheSchwartz::Simple, TheSchwartz::Simple::Job
=status show
=books intermediate
=author dsdickinson
=archive 1
=comments_disqus_enable 1

=abstract start

Welcome to the second part of how to setup and use <a href="https://metacpan.org/pod/TheSchwartz">TheSchwartz</a> Perl module.
In part one of this tutorial, we covered how to setup the accompanying database and write a script to insert a job for queueing.
In this continuation, we will finish things up by adding the worker scripts to process the jobs inserted into the database and 
also create a service script to daemonize the runner. This will give us a complete queueing system we can use for many different tasks.

=abstract end

<h2>Overview</h2>
Once we are done with this lesson, we will have coded four seperate files for our queueing system.
1) Job insert script (send_email.pl)
2) Worker runner script (send_email_runner.pl)
3) Worker library (Worker/SendEmail.pm)
4) Daemon service script (send_email.service)

We have already coded the first file (send_email.pl) in part one of this lesson. In part two we will cover coding files 2, 3 and 4 from above.

This is where everything will go on our system respectively from above:
<code lang="shell">
/usr/local/bin/send_email.pl
/usr/local/bin/send_email_runner.pl
/usr/local/lib/Worker/SendEmail.pm
/etc/systemd/system/send_email.service
</code>

<h2>Worker Runner Script</h2>
<code lang="shell">/usr/local/bin/send_email_runner.pl</code>
This wil be the script that constantly runs in the background to monitor our database for new jobs to process.
Later, we will daemonize this script to run as a service.

Here's what our worker runner script will look like. 
<code lang="shell">
#!/usr/bin/perl

use lib "/usr/local/lib";

use TheSchwartz;
require Worker::SendEmail;
 
my $dbname      = "schwartz";
my $host        = "localhost";
my $port        = "5432"; 
my $username    = "USERNAME";
my $password    = "PASSWORD";

# Database connection string.
my $dsn = "dbi:Pg:dbname=$dbname;host=$host";

# Add on credentials
my $databaseref = [
	{
		dsn => $dsn,
		user => $username,
		pass => $password,
	},
];

# Create schwartz client object
my $sclient = TheSchwartz->new(
	databases => $databaseref,
	driver_cache_expiration => 900,
);

# Specify the type of job to work on (from funcmap.funcname in db)
$sclient->can_do("Worker::SendEmail");

my $log_file = "/var/tmp/send_email_runner.log";
open(LOG,">>$log_file") or die "Can not open $log_file!";
{ my $ofh = select LOG;
  $| = 1;
  select $ofh;
}

warn "Service started. Using dbhost: $host / dbname: $dbname\n";

$loopcount = 0;
$sleepint = 10;
if ($loopcount eq 0) {
	# main loop of program; goes forever, running jobs
	$sclient->work($sleepint);
} else {
	for (my $i = 0; $i <= $loopcount; $i++) {
		$sclient->work_once();
		sleep $sleepint;
	}
}

exit 0;
</code>

This assumes you have credentials squared away properly in the database with access to the schwartz database.
Also, dont forget line 45 as that tells our script how to get to our library that houses the ever important work() function, which we will get to a bit later and require at line 49.
So as you can see we are connecting to the database so the script can query the available jobs that have been inserted into the database.
Note that on line 75, we are specifying which type of job we want to process. Here that is the "Worker::SendEmail" type of job from funcmap.funcname in the database. So this script will
only process those types of jobs. Typically I like to add logging to these process to facilitate troubleshooting which is what is happening on lines 77-82.
Lines 86-97 creates the infinite loop that will continue to check our database queue for jobs until the script is stopped.
The sleepint value gives the work() function a value to sleep before it looks at the queue again in case there are performance concerns. Here we specify 10 seconds between checks.
We've also added some flexibilty here for testing with the work_once() function. If we set loopcount > 0 it will go here and it will only get one job of our type off the queue.

So how does it now what do to when it hits the work() function? Well that is another function we are going to code in a new and seperate library module we will be creating next.

<h2>Worker Runner Script Library Module</h2>

This is where we will put our work() function. <a href="https://metacpan.org/pod/TheSchwartz::Worker">TheSchwartz::Worker</a> page has some valuable information on using the 
superclass as we will be doing in the below code.

<code lang="shell">/usr/local/lib/Worker/SendEmail.pm</code>

<code lang="shell">
package Worker::SendEmail;

use base qw( TheSchwartz::Worker );
use Data::Dump qw(dump);

my $self = bless({}, __PACKAGE__);

sub grab_for { 120 }
sub max_retries { 30 }
sub retry_delay { 60 }

my $log_file = "/var/tmp/send_email_worker.log";
open(LOG,">>$log_file") or die "Can not open $log_file!";
{ my $ofh = select LOG;
  $| = 1;
  select $ofh;
}
 
sub work {
	my ($self, $job) = @_;

	print LOG "=======================================================\n";
	print LOG `date` . "\n";
	print LOG "=======================================================\n";
	print LOG "Job:\n";
	print LOG dump $job;

	my $args		= $job->arg;
	my $client		= $job->handle->client;

	print LOG "Args:\n";
	print LOG dump $args . "\n";

	# Get args we created in worker job record. (See job.arg data in db).
	my $from		= $args->{from} ||= 'noreply@someplace.com';
	my $to			= $args->{to};
	my $subject		= $args->{subject};
	my $body		= $args->{body};

	print LOG "From: $from\n";
	print LOG "To: $to\n";
	print LOG "Subject: $subject\n";
	print LOG "Body: $body\n";

	# Let make sure we have all the required data for email.
	my @rqd_fields = qw(from to subject body);
	foreach my $rqd_field (@rqd_fields){
		if ( ! exists $args->{$rqd_field} || $args->{$rqd_field} eq ""){
			print LOG "Worker::SendEmail FAILED!  Missing required data!! (field: $rqd_field) \n";
			$job->permanent_failure( "Worker::SendEmail missing required field", 1 );
			return(1);
		}
	}

	my $sendmail	= "/usr/sbin/sendmail -t";

	print LOG "sendmail: $sendmail\n";

	# Do not change the order of the headers.
	open(SENDMAIL, "|$sendmail") or die "Cannot open $sendmail: $!";
	print SENDMAIL "From: $from" . "\n";
	print SENDMAIL "To: $to" . "\n";
	print SENDMAIL "Subject: $subject " . "\n";
	print SENDMAIL "Content-type: text/plain" . "\n";
	print SENDMAIL $body;
	close (SENDMAIL);

	print LOG "All done!\n";

    $job->completed();
}

1;
</code>

This is the work() function that the runner script will execute. At the top of the script you will notice four values we are setting for the worker:
sub grab_for { 120 } = This is a timeout value for the job. After this time expires and the job hasn't completed or failed it assumes it has crashed and becomes available for another worker.
sub max_retries { 30 } = The number of times a worker should attempt to process any given job.
sub retry_delay { 60 } = The number of seconds to wait to retry a failed job again.
So in the above example, we will retry a failed job for half an hour, after which it will be permanently marked failed and not attempted anymore.
Again we have added logging which can be crucial for troubleshooting whats going on in these workers.
As we enter the work() you'll notice we are passing in the arguments data that the job holds from the database record. 

<code lang="shell">
	my $args		= $job->arg;
</code>

Here's a database refresher:

<code>
 jobid |    funcname       |                               args                                |      insert_time       |       run_after        
-------+-------------------+-------------------------------------------------------------------+------------------------+------------------------
     1 | Worker::SendEmail | \x05                                                             +| 2016-03-20 00:43:12-04 | 2016-03-20 00:43:22-04
       |                   | \x03\000\000\000\x04                                             +|                        | 
       |                   | \x17I, am your father. -Dad\000\000\000\x04body                  +|                        | 
       |                   | \x19darth.vader@cloudcity.com\000\000\000\x04from                +|                        | 
       |                   | \x1Cluke.skywalker@cloudcity.com\000\000\000\x02to               +|                        | 
       |                   | \x04Luke\000\000\000\x07subject                                   |                        | 
(1 row)
</code>

We are simplying grabbing those args values, setting them to some variables and checking that they are all there.
<code>
	my $from		= $args->{from} ||= 'noreply@someplace.com';
	my $to			= $args->{to};
	my $subject		= $args->{subject};
	my $body		= $args->{body};

	my @rqd_fields = qw(from to subject body);
	foreach my $rqd_field (@rqd_fields){
		if ( ! exists $args->{$rqd_field} || $args->{$rqd_field} eq ""){
			print LOG "Worker::SendEmail FAILED!  Missing required data!! (field: $rqd_field) \n";
			$job->permanent_failure( "Worker::SendEmail missing required field", 1 );
			return(1);
		}
	}
</code>

Finally, the script creates the email and sends it out via the sendmail command. I know there are much better ways of doing this using email perl modules 
such as <a href="https://metacpan.org/pod/Mail::Sendmail">Mail::Sendmail</a> but I wanted to keep things simple by not introducing any other tech.
Once the email gets sent this particular job is marked as completed in the database and will not be run again.
<code>
	my $sendmail	= "/usr/sbin/sendmail -t";

	print LOG "sendmail: $sendmail\n";

	# Do not change the order of the headers.
	open(SENDMAIL, "|$sendmail") or die "Cannot open $sendmail: $!";
	print SENDMAIL "From: $from" . "\n";
	print SENDMAIL "To: $to" . "\n";
	print SENDMAIL "Subject: $subject " . "\n";
	print SENDMAIL "Content-type: text/plain" . "\n";
	print SENDMAIL $body;
	close (SENDMAIL);

	print LOG "All done!\n";

    $job->completed();
</code>

<h2>Daemon Service</h2>
Now our final step will be to setup our worker runner to A) always run in the background and B) always startup when the system starts. To do this we will
need to create a new systemd service. This is fairly straight forward to accomplish.

Create the following file:
<code lang="shell">/etc/systemd/system/send_email.service</code>

<code lang="shell">
# vi /etc/systemd/system/send_email.service
[Unit]
Description=Service for send_email runner.
After=network.target

[Service]
Type=simple
ExecStart=/usr/local/bin/send_email_runner.pl
TimeoutStartSec=0

[Install]
WantedBy=default.target
</code>

Get the service up and running.
<code lang="shell">
> chmod 644 /etc/systemd/system/send_email.service
> sudo systemctl daemon-reload
> systemctl start send_email.service
> systemctl list-units -t service | grep send_email
  send_email.service                 loaded active running Service for send_email runner.
</code>

The above validation means the service is up and running. And now we should have a fully functional queueuing system!

<h2>Conclusion</h2>
This concludes the tutorial for setting up a queueing system using TheSchwartz. It's a pretty good system that proves to be reliable. I have used it in 
the past to run many different types of runners concurrently on the same system with out fail. Enjoy and may TheSchwartz be with you!

