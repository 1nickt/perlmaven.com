=title The problem with Perl 4 style libraries
=timestamp 2017-02-11T08:00:11
=indexes -w
=tags screencast
=books advanced
=status show
=author szabgab
=original the-problem-with-libraries
=translator nselem
=comments_disqus_enable 1

=abstract start

Ahora que hemos aprendido a usar <a href="/librerias-perl-4">librerías en Perl 4</a>, estudiaremos qué problemas tienen.
A pesar de que siguen en uso, pertenecen a una época muy antigua, antes de que Perl 5 apareciera en 1995.
=abstract end

<slidecast file="/media/videos/advanced-perl/libraries-and-modules/the-problem-with-libraries" youtube="UZeEzD5459c" />

De la nada:
La librería (<hl>library.pl</hl>) que tenemos en <a href="/librerias-perl-4">librerías en Perl 4</a> contiene 3 funciones y una variable global (<hl>$base</hl>). Si nosotros hacemos <hl>import</hl> de la librería tal como está hecho en <hl>perl4_app.pl</hl>
entonces tendremos todas las funciones y la variable disponibles en nuestro script.

El problema viene cuando usas más de una librería en un mismo script y algunas de las funciones están declaradas con el mismo nombre en ambas librerías. Por ejemplo tenemos una función matemática <hl>add</hl> en esta librería, supongamos que tenemos otra función <hl>add</hl> totalmente diferente relacionada con inventarios en otra librería. Si escribes un script que requiera ambas librerías, ambos importarán la función <hl>add</hl> y esta funciones se sobre escribirán una a la otra. Más específicamente, la segunda función cargada (usando require) sobre escribirá a la primera.Lo que significa pues que el orden de los requires importa, y probablemente enloquecerá a alguien que esté tratando de entender por qué el script actúa extraño.

This potential of collision just increases with the number of additional libraries used.

And perl does not even warn you about this, of course, because this is Perl 4 style coding without <hl>use warnings</hl>.
(Although we could turn on warnings by adding <hl>-w</hl> to the sh-bang line:

<code>
#!/usr/bin/perl -w
</code>

Even more problematic is that now all the internal functions (<hl>validate_parameters</hl> in our case),
and all the internal global variables (<hl>$base</hl> in our case) will be available and global
in the script as well.

So in order to stay clear from interfering with the internals of the library, you need to actually
know about the <hl>$base</hl> variable and you need to avoid it in your code.

It's even worse when the library is updated. Especially if the library writer is not aware of all the script
using it then they can introduce a new function or a new variable that will start to collide with something
in one of the scripts using that module.


<h2>Early Conclusion</h2>

While Perl libraries were useful, and they are still much better than copy-paste, their time is over.
So we'll learn how to convert them to something more modern.

<h2>Prefix everything</h2>

One of the solutions to the problem of collision is to use prefixes. Prefix every function and every global
variable name in the library with some specific word unique to that library. For example a library
with functions related to math could be prefixed with <hl>_math_</hl> or <hl>calc_</hl> as in the example.

<b>calc_perfix_lib.pl</b>:

<code lang="perl">
$calc_base = 10;

sub calc_add {
    calc_validate_parameters(@_);

    my $total = 0;
    $total += $_ for (@_);
    return $total;
}

sub calc_multiply {
}

sub calc_validate_parameters {
    die 'Not all of them are numbers'
        if  grep {/\D/} @_;
    return 1;
}

1;
</code>

This reduces the potential for collision in the scripts using this module, but the inconvenience of this solution
is that now we need to use these prefixes everywhere, including inside the library. That requires more typing
and code which is probably less readable.

Besides, Perl 5 has a perfectly nice solution for this using namespaces (usually also referred to as modules).
We are going to talk about those in the next episode.
