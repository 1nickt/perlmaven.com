=title "my" variable masks earlier declaration in same scope
=timestamp 2013-04-19T16:46:56
=indexes my, scope
=status show
=original my-variable-masks-earlier-declaration-in-same-scope
=books beginner_book
=author szabgab
=translator terrencehan
=index 1
=archive 1
=feed 1
=comments 1
=social 1

=abstract start

如果错误地尝试在一个作用域两次声明同一个变量，会产生如下编译时警告：

<code>
"my" variable ... masks earlier declaration in same scope at ... line ...
</code>

这是如何产生的？那么，每次循环的迭代重新声明的变量有如何有效呢？

如果不能在一个作用域写两次<hl>my $x</hl>，那我该如何清空变量呢？

=abstract end

来看下面几个例子的不同之处：

<h2>Plain script</h2>

<code lang="perl">
use strict;
use warnings;

my $x = 'this';
my $z = rand();
my $x = 'that';
print "OK\n";
</code>

此例会产生如下编译时警告：

<code>
"my" variable $x masks earlier declaration in same scope at ... line 7. )
</code>

因为这个脚本也会打印"OK"，所以这仅是一个警告。


<h2>Block in conditional statement</h2>

<code lang="perl">
use strict;
use warnings;

my $z = 1;
if (1) {
    my $x = 'this';
    my $z = rand();
    my $x = 'that';
}
</code>

这次产生如下警告：

<code>
"my" variable $x masks earlier declaration in same scope at ... line 7.
</code>

在这两个例子中，我们都在同一个作用域中声明了两次<hl>$x</hl>，并且都产生了编译时警告。

在第二个例子里，我们对<hl>$z</hl>也进行了两次声明，但是没有产生任何警告。这是因为<hl>$z</hl>所在的代码块是一个独立的<a href="/scope-of-variables-in-perl">作用域</a>。

<h2>The scope of a function</h2>

相同的代码，但这次是在函数里：

<code lang="perl">
use strict;
use warnings;

sub f {
    my $x = 'this';
    my $z = rand();
    my $x = 'that';
}
f(1);
f(2);
</code>

Here too, you get the same compile-time warning (once) for the <hl>$x</hl> variable.
Even though the variable <hl>$z</hl> will 'spring to existence' repeatedly,
once for every call of the function.
This is ok. The <hl>$z</hl> variable does not generate the warning:
Perl can create the same variable twice, it is only you who are not supposed to do it.
At least not within the same scope.

<h2>The scope of a for loop</h2>

Same code, but in a loop:

<code lang="perl">
use strict;
use warnings;

for (1 .. 10) {
    my $x = 'this';
    my $z = rand();
    my $x = 'that';
}
</code>

This too will generate the above warning for <hl>$x</hl> once(!), but won't generate
any warning for <hl>$z</hl>.

In this code the same thing happens for <b>every</b> iteration:
Perl will allocate the memory for <hl>$z</hl> variable for every iteration.

<h2>What does "my" really mean?</h2>

The meaning of <hl>my $x</hl> is that you tell perl, and specifically to <hl>strict</hl>,
that you would like to use a private variable called <b>$x</b> in the <a href="/scope-of-variables-in-perl">current scope</a>.
Without this, perl will look for a declaration in the upper scopes and if
it cannot find a declaration anywhere it will give a compile-time error
<a href="/global-symbol-requires-explicit-package-name">Global symbol requires explicit package name</a>
Every entry in a block, every call to a function, every iteration in a loop is a new world.

On the other hand, writing <hl>my $x</hl> twice in the same scope just means that you try to tell the same
thing twice to Perl. It is not necessary and usually it means there is a mistake somewhere.

In other words, the warning we got is related to the <b>compilation</b> of the code and not the running.
It is related to the declaration of the variable by the developer and not to the memory-allocation
done by perl during run-time.

<h2>How to empty an existing variable?</h2>

So if we cannot write <hl>my $x;</hl> twice in the same scope, then how can we set the variable to be "empty"?

First of all, if a variable is declared inside a scope, that is, inside ant curly braces, then it will automatically
disappear when the execution leaves the <a href="/scope-of-variables-in-perl">scope</a>.

If you just want to "empty" the scalar variable in the current scope, set it to <hl>undef</hl>,
and if it is an <a href="/undef-on-perl-arrays-and-hashes">array or a hash</a>, then empty them by assigning an empty list to them:

<code lang="perl">
$x = undef;
@a = ();
%h = ();
</code>

So just to clarify. "my" tells perl you'd like to use a variable.
When Perl reaches the code where you have "my variable" it allocates memory for the variable and its content.
When Perl reaches the code <hl>$x = undef;</hl>  or  <hl>@x = ();</hl>  or  <hl>undef @x;</hl> it will
remove the content of the already existing variable.


