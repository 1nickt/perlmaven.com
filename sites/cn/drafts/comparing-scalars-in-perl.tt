=title Perl中标量的比较
=timestamp 2013-05-01T12:45:56
=indexes eq, ne, lt, gt, le, ge, ==, !=, <, >, <=, >=
=status show
=original comparing-scalars-in-perl
=books beginner_book
=author szabgab
=translator terrencehan
=index 1
=archive 1
=feed 1
=comments 1
=social 1

=abstract start

在上节<a href="/perl-tutorial">Perl tutorial</a>介绍了<a href="/scalar-variables">标量</a>，并且看到了数字和字符串之间的转换。我们简单提了一下<b>if</b>条件语句，但是没有看到如何比较两个标量，这一节将会对此进行介绍。

=abstract end

给定两个标量 $x 和 $y，如何来比较它们呢？ 1，1.0 以及 1.00 是相等的么？那 "1.00" 有如何呢？ "foo" 和 "bar" 哪个更大呢？

<h2>两类比较操作符</h2>

Perl有两类比较操作符。如之前看到的二元操作符，加号（+），连接符（.）和重复符（x），这里的操作符定义了操作数的行为以及如何比较它们。

这两类操作符是：

<code>
Numeric    String         Meaning
==            eq           equal
!=            ne           not equal
<             lt           less than
>             gt           greater than
<=            le           less than or equal
>=            ge           greater then or equal
</code>

左侧的操作符会按照数字的形式比较值，而右侧的（中间一列）会根据ASCII码表或者当前的位置比较值。

来看几个例子：

<code lang="perl">
use strict;
use warnings;
use 5.010;

if ( 12.0 == 12 ) {
  say "TRUE";
} else {
  say "FALSE";
}
</code>

在这个简单的例子中，Perl会打印 TRUE ，这是因为<hl>==</hl>操作符比较两个数字，并且不在乎数字是整型还是浮点型。

更有趣的是下面的比较

<code>
"12.0" == 12
</code>

结果也是TRUE，因为Perl的<hl>==</hl>操作符会把字符串转换成数字。

<code>
 2  < 3  为TRUE，因为<比较两个数字

 2  lt 3 也是TRUE，因为ASCII表中2在3的前面

12 > 3  显然也为TRUE

12 gt 3 会返回FALSE
</code>

有些人一开始可能会觉得奇怪，但是如果你想一下就能知道，Perl在比较字符串的时候是一个字符一个字符比较的。所以在比较"1"和"3"的时候，因为它俩不同，且在ASCII表中"1"在"3"前面，这就界定了12作为字符串的时候比字符串3小。

你需要确认比较的对象是你想要的！

<code>
"foo"  == "bar" 会返回TRUE
</code>

如果你使用<hl>use warnings</hl>开启警告，会获得两条警告信息。警告的原因是你在数值比较 == 的时候传入了两个字符串作为数字。在上一节我们提到过，Perl会查看字符串的左边并尝试把所有有意义的转换成数字。因为这两个字符串以字母开头，它们都会转换成0. 0 == 0 返回真。

另一方面：

<code>
"foo"  eq "bar"  FALSE
</code>

So you have to make sure you compare values as you want them to be compared!

The same happens when you compare

<code>
"foo"  == "" will be TRUE
</code>

and

<code>
"foo"  eq "" will be FALSE
</code>


This table might be handy to see the results:

<code>
 12.0   == 12    TRUE
"12.0"  == 12    TRUE
"12.0"  eq 12    FALSE
  2     <   3    TRUE
  2    lt   3    TRUE
 12     >   3    TRUE
 12    gt   3    FALSE ! (look out, might not be obvious at first)
"foo"  ==  ""    TRUE  ! (You get warnings if you used the "warnings" pragmata)
"foo"  eq  ""    FALSE
"foo"  == "bar"  TRUE  ! (You get warnings if you used the "warnings" pragmata)
"foo"  eq "bar"  FALSE
</code>

Finally an example where people can fall in a trap is when you get some input from the
user and after carefully chomping off the newline from the end you try to check if the
given string is empty.

<code lang="perl">
use strict;
use warnings;
use 5.010;

print "input: ";
my $name = <STDIN>;
chomp $name;

if ( $name == "" ) {   # wrong! you need to use eq instead of == here!
  say "TRUE";
} else {
  say "FALSE";
}
</code>

If you run this script and type in "abc" you will get that it is TRUE,
as if perl thought "abc" is the same as the empty string

